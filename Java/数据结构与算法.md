# 数据结构

## 基本概念

### 数据

用来描述客观事物的数值、字符，能输入到计算机中且被计算机处理的各种符号的集合。

数据就是信息在计算机中的表示。

### 数据元素

数据的基本单位，在计算机中，通常把数据元素作为一个整体进行处理。

数据元素有若干个数据项组成

如：描述学生信息的一条数据就是一个数据元素

​		描述学生信息中的姓名、年龄、组别、性别等，都是数据项

### 数据对象

一组相同性质的数据元素的集合就是数据对象

如：一个学校中所有学生的集合

### 数据结构

相互之间存在一种或多种特定关系的数据元素的集合；简单来说，就是数据元素之间的关系

数据的逻辑结构一般采用二元组的形式来定义：

数据结构 = （D，S）

其中：D 是数据元素的集合，S 是D中元素之间的关系的集合

数据结构分为逻辑结构和物理结构。

**逻辑结构：**

> 集合：数据仅仅属于同一个集合，没有其他的相互关系
>
> > 例如：
> >
> > 二元组：set=(D,S) ，其中
> >
> > ​	D = {01,02,03,04}
> >
> > ​	S = {}
> >
> > 在set集合中，数据元素处理属于同一个集合外不存在其他的关系，这就是集合的结构
> >
> > ![image-20210809114718448](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210809114718448.png)
>
> 线型：描述一个一对一的关系
>
> > 例如：
> >
> > 二元组：lineartiy=(D,S) ，其中
> >
> > ​	D = {01,02,03,04,05,06}
> >
> > ​	S = {<01,03>,<02,04>,<03,06>,<06,02>,<04,05>}
> >
> > 在lineartiy中，数据元素是有序的，有一个被称为**’第一个‘**的元素（01），还有一个被称为最后一个的元素（03）；除了第一个元素外，其他每个元素都有一个直接前驱元素，除了最后一个元素外，其他每个元素都有一个直接后继元素。
> >
> > 数据元素之间是一对一的关系
> >
> > ![image-20210809115734128](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210809115734128.png)
>
> 树形：描述一个一对多的关系
>
> > 例如：
> >
> > 二元组：tree=(D,S) ，其中
> >
> > ​	D = {01,02,03,04,05,06}
> >
> > ​	S = {<01,02>,<01,03>,<02,04>,<02,05>,<03,06>}
> >
> > 在tree数据结构中，除了第一个元素之外，每个元素有且只有一个直接前驱元素，但每一个元素都可以有多个直接后继元素
> >
> > 数据元素之间是一对多的关系
> >
> > ![image-20210809121212856](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210809121212856.png)
>
> 图形：描述一个多对多的关系
>
> > 例如：
> >
> > 二元组：graph=(D,S) ，其中
> >
> > ​	D = {01,02,03,04,05,06}
> >
> > ​	S = {<01,02>,<01,03>,<02,05>,<05,06>,<05,04>,<06,02>,<04,05>}
> >
> > 在graph数据结构中，每个元素都可以有多个直接前驱元素，每个元素也可以有多个直接后继元素
> >
> > ![image-20210809120851504](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210809120851504.png)

**物理结构：**

数据的为例结构就是逻辑结构在计算机中的存储表示，他有两种表现形式：

> 顺序存储：
>
> >就是使用一块连续的存储空间，数据之间紧紧挨在一起，数据的前驱和后继关系可以通过元素在内存中的相对位置反应出来
>
> 链式存储：
>
> > 数据元素的存储位置不是连续的，每个元素保存下一个元素的存储位置（内存地址）

## 抽象数据类型

### 数据类型

一组性质相同的数据的集合以及该集合上的数据操作的总称

比如：java的int类型，数据的集合：-2147483648-2147483647，在这组数据上操作加，减，乘，除......

### 抽象数据类型

abstract data type ，建成 ADT

有一组数据模型及该模型上的数据操作组成，只讨论1其逻辑类型，不关心她的实现

抽象数据类型一般使用一个三元组表示：

ADT = (D,S,P)

D 是数据对象，S 是D上的关系，P 是在数据上的操作

在定义抽象数据类型的时候，可以使用一下的格式；

```java
 ADT 抽象数据类型名 {
     数据对象：<数据对象的定义>;
     数据关系：<数据关系的定义>;
     数据操作：<数据操作的定义>;
}
```

抽象数据类型可以对应一个java类，数据对象与数据关系，可以通过类的成员变量来存储和表示；数据操作可以使用方法来实现

## 线性表

### 线性表的抽象数据类型：

抽象数据类型可以对应一个java类，生育金对象元素之间的关系可以通过成员变量来存储和表示，数据操作可以通过一组方法来实现

List接口：使用java中的接口来表示ADT中的数据操作，在使用类完成抽象数据类型时，只要这个类实现接口均可完成抽象数据类型的定义操作

```java
 ADT List {
     数据对象：D={ai 属于某个数据类型，1=0,1,2,3,4....}
     		 D={a0,a1,a2,a3,a4....an}，所有的元素都是同一个数据类型
     数据关系：R={<ai,ai+1>}
     数据操作：
         getSize()：返回线性表中元素的个数
         isEmpty()：判断线性表是否为空，为空返回true，否则返回false
         insert(i,e)：在线性表的i索引值位置插入元素e
         contanins(e)：判断线性表中是否存在元素e，存在返回true
         indexOf(e)：返回元素e在线性表中的索引值，如果不存在则返回-1
         remove(e)：删除线性表中第一个与e相同的元素，删除成功后返回删除的元素
         remove(i)：删除线性表中指定索引值的元素，并返回删除的元素
         replace(i,e):把线性表中索引值为i的元素替换为e
         get(i)：返回线性表中索引值为i的元素
         insertBefore(p,e)：在线性表中元素p的前面插入元素e
         insertAfter(p,e)：在线性表中元素p的后面插入元素e
}
```

### 线性表的顺序存储与实现

线性表的顺序存储就是使用一组地址连续的存储空间来依次存储线性表中的元素

以元素在计算机内存的地址相邻性表示数据元素之间的关系

在java中可以使用数组来存储线性表中的数据元素，数组就是一块连续的储存空间

#### 顺序存储的特点

优点：

- 顺序存储是使用数组实现的，数组可以通过索引值快速访问

缺点：

- 在插入或删除元素时，需要移动大量的元素
- 当线性表册长度变化较大时，我们很难确定存储空间的容量

引用场景：

- 适合存储的元素，插入或删除操作比较少，主要是查询操作

#### 具体实现

```java
public class MyArrayList implements MyList {
    private Object [] elements;//定义数组保存数据元素
    private static final int DEFAULT_CAPACITY = 16;//数组默认初始化容量
    private int size;//保存数据元素个数

    public MyArrayList(){
        elements = new Object[DEFAULT_CAPACITY];
    }
    public MyArrayList(int initialCapacity){
        elements = new Object[initialCapacity];
    }

    public MyArrayList(Object[] elements) {
        this.elements = elements;
    }

//    返回元素的个数
    @Override
    public int getSize() {
        return size;
    }

//    判断线性表是否为空
    @Override
    public boolean isEmpty() {
        return size==0;
    }

//    在线性表的i位置插入e
    @Override
    public void insert(int i, Object e) {
        if (i < 0 || i > size){
            throw new IndexOutOfBoundsException("索引值" + i + "越界");
        }
//        数组已满，则需要扩容
        if ( size >= elements.length){
            expandSpace();//数组扩容
        }
//        从i开始，把元素后移
        for (int j = size; j > i ; j--) {
            elements[j] = elements[j-1];
        }
        elements[i] = e;
        size++;
    }

//    数组扩容
    public void expandSpace(){
        Object [] newElements = new Object[elements.length*2];
        for (int i = 0; i < elements.length ; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
    }


//    判断当前线性表中是否包含元素e
    @Override
    public boolean contanins(Object e) {
        return indexOf(e)>=0;
    }

//    返回元素e在线性表中的索引值，如果不存在则返回-1
    @Override
    public int indexOf(Object e) {
        if (e == null){
            for (int i = 0; i < size ; i++) {
                if(elements[i] == null){
                    return i;
                }
            }
//            throw new NoClassDefFoundError("没有当前元素"+e);
        }else {
            for (int i = 0; i < size ; i++) {
                if(e.equals(elements[i])){
                    return i;
                }
            }
        }
        return -1;
    }

//    删除定义个与e匹配的元素
    @Override
    public Object remove(Object e) {
        int index = indexOf(e);
        if (index<0){
            return null;
        }
        return remove(index);
    }

//    删除索引值为i的元素
    @Override
    public Object remove(int i) {
//        判断i是否越界，不越界的化将i+1依次前移，最后一位赋值null
        if ( i < 0 || i>= size){
            throw new IndexOutOfBoundsException("数组下标"+i+"越界");
        }
        Object item = elements[i];
        for (int j = i; j < size ; j++) {
            elements[j]=elements[j+1];
        }
        elements[size-1]=null;
        size--;
        return item;
    }

//    把索引值为i的元素替换为e
    @Override
    public Object replace(int i, Object e) {
//        判断i是否越界，不越界就替换
        if ( i < 0 || i>= size){
            throw new IndexOutOfBoundsException("数组下标"+i+"越界");
        }
        Object item = elements[i];
        elements[i] = e;
        return i;
    }

//    获取索引值为i的元素
    @Override
    public Object get(int i) {
        //        判断i是否越界，不越界就返回
        if ( i < 0 || i>= size){
            throw new IndexOutOfBoundsException("数组下标"+i+"越界");
        }
        return elements[i];
    }

//    在指定的元素前插入元素
    @Override
    public boolean insertBefore(Object p, Object e) {
        int index = indexOf(p);
        if (index<0){
            return false;
        }else{
            insert(index,e);

            return true;
        }
    }
    //    在指定的元素前插入元素
    @Override
    public boolean insertAfter(Object p, Object e) {
        int index = indexOf(p);
        if (index<0){
            return false;
        }else{
            insert(index+1,e);

            return true;
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        for (int i = 0; i < size ; i++) {
            sb.append(elements[i]);
            if (i<size-1){
                sb.append(",");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}
```

### 线性表的链式存储与实现

#### 单向链表（单链表）

每个存储单元最少有两个存储域，一个用来存储数据，一个用来保存下一个存储单元的引用

各个存储单元的地址可以是不连续的

<img src="https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210813130244361.png" alt="image-20210813130244361"  />

 #### 单向链表的实现

```java
public class MySingleLink implements MyList {
    private Node head;  //头结点
    private int size;  //保存元素的个数

//    返回元素的个数
    @Override
    public int getSize() {
        return size;
    }

//    判断线性表是否为空
    @Override
    public boolean isEmpty() {
        return size == 0;
    }

//    在指定位置插入元素
    @Override
    public void insert(int i, Object e) {
        if (i < 0 || i > size){
            throw new IndexOutOfBoundsException( i + "越界");
        }

        Node newNode = new Node(e,null);
        if (head == null){
            head = newNode;
        }else{
            if (i == 0){
                newNode.next = head;
                head = newNode;
            }else {
                Node pNode = head;
                for (int x = 1;x < i;x++){
                    pNode = pNode.next;
                }
                newNode.next = pNode.next;
                pNode.next = newNode;
            }
        }
        size ++;
    }

//    判断线性表中是否包含指定的元素
    @Override
    public boolean contanins(Object e) {
        return  indexOf(e) >= 0;
    }

//    查新指定元素在线性表中的索引值
    @Override
    public int indexOf(Object e) {
        Node pNode = head;
        for (int i = 0; i < size ; i++) {
            if (e == null && pNode.data == null){
                return  i;
            }else if (e.equals(pNode.data)){
                return i;
            }
            pNode = pNode.next;
        }
        return -1;
    }

//    删除第一个与e相同的元素
    @Override
    public Object remove(Object e) {
        int index = indexOf(e);
        if (index < 0){
            return null;
        }
        return remove(index);
    }

//    删除指定索引的元素
    @Override
    public Object remove(int i) {
        if (i < 0 || i >= size){
            throw new IndexOutOfBoundsException(i + "越界");
        }
        Node pNode = head;
        if (i == 0){
            head = head.next;
            size--;
            return head.data;
        }else{
            for (int j = 0; j < i-1 ; j++) {
                pNode = pNode.next;
            }
            Object old = pNode.next.data;
            pNode.next = pNode.next.next;
            size--;
            return old;
        }
    }

//    把索引为i的元素替换为e
    @Override
    public Object replace(int i, Object e) {
        if (i < 0 || i >= size){
            throw new IndexOutOfBoundsException(i + "越界");
        }
        Node pNode = getNode(i);
        Object old = pNode.data;
        pNode.data = e;
        return old;
    }

//    返回i索引值的元素
    @Override
    public Object get(int i) {
        return getNode(i).data;
    }

//    返回索引值为i的node
    public Node getNode(int i){
        if (i < 0 || i >= size){
            return null;
        }
        if (i ==0){
            return head;
        }
        Node pNode = head;
        for (int j = 0; j < i ; j++) {
            pNode = pNode.next;
        }
        return pNode;
    }

//    在指定元素p前面插入元素e
    @Override
    public boolean insertBefore(Object p, Object e) {
        int index = indexOf(p);
        if (index < 0){
            return false;
        }
        insert(index,e);
        return true;
    }
//    在指定元素p后面插入元素e
    @Override
    public boolean insertAfter(Object p, Object e) {
        int index = indexOf(p);
        if (index < 0){
            return false;
        }
        insert(index+1,e);
        return true;
    }

    private class Node{
        Object data;
        Node next;
        public Node(Object data, Node next) {
            this.data = data;
            this.next = next;
        }
    }

    @Override
    public String toString() {

        StringBuilder sb = new StringBuilder();
        sb.append("[");
        Node pNode = head;
        for (int i = 0; i < size ; i++) {
            sb.append(pNode.data);
            if (pNode.next != null){
                sb.append(",");
            }
            pNode = pNode.next;
        }
        sb.append("]");

        return String.valueOf(sb);
    }
}

```

#### 双向链表

单向链表只能通过一个节点引用访问2它的后继节点，不能访问前驱节点，如果要找某一节点的前驱节点，只能通过头节点依次寻找

双向链表增加了一个存储域，一个用来存储前驱，一个用来存储数据，一个用来存储后继

![image-20210814115828946](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210814115828946.png)

#### 双向链表的实现

```java
package com.zym.a;

public class MyDualLinkedList implements MyList {

    private Node first;
    private Node last;
    private int size;

//    返回元素的个数
    @Override
    public int getSize() {
        return size;
    }

//    判断链表是否为空
    @Override
    public boolean isEmpty() {
        return size == 0;
    }

//    添加元素
    @Override
    public void insert(int i, Object e) {
        if (i < 0 || i > size){
            throw new IndexOutOfBoundsException(i + "越界");
        }else if (i == 0){
            Node pNode = new Node(null,e,first);
            if (first == null){
                last = pNode;
            }else{
                first.prve = pNode;
            }
            first = pNode;
            size++;
        }else if (i == size){
            Node pNode = new Node(last,e,null);
            last.next = pNode;
            last = pNode;
            size++;
        }else{
            Node pNode = getNode(i);
            Node prveNode = pNode.prve;
            Node newNode = new Node(prveNode,e,pNode);
            prveNode.next=newNode;
            pNode.prve=newNode;
            size++;
        }
    }

    //获取第i个节点
    private Node getNode(int i){
        Node pNode = first;
        for (int j = 0; j < i; j++) {
            pNode = pNode.next;
        }
        return pNode;
    }

//    判断元素e是否存在
    @Override
    public boolean contanins(Object e) {
        return indexOf(e) >= 0;
    }

//    元素e在链表中的索引
    @Override
    public int indexOf(Object e) {
        int i =0;
        if (e == null){
            for (Node pNode = first;pNode != null;pNode = pNode.next){
                if (pNode.data == null){
                    return i;
                }
                i++;
            }
        }else {
            for (Node pNode = first;pNode != null;pNode = pNode.next){
                if (pNode.data.equals(e)){
                    return i;
                }
                i++;
            }
        }
        return -1;
    }

//    删除指定元素
    @Override
    public Object remove(Object e) {
        int index = indexOf(e);
        if (index < 0){
            return null;
        }
        return remove(index);
    }

//    删除指定索引元素
    @Override
    public Object remove(int i) {
        if (i < 0 || i>=size ){
            throw new IndexOutOfBoundsException(i + "越界");
        }
        Node pNode = getNode(i);
        if (pNode.prve == null){
            first = pNode.next;
            first.prve = null;
        }else{
            pNode.prve.next = pNode.next;
        }

        if (pNode.next == null){
            pNode.prve.next = null;
            last = pNode.prve;
        }else {
            pNode.next.prve = pNode.prve;
        }

        size--;
        return pNode.data;
    }

//    修改指定索引值的元素
    @Override
    public Object replace(int i, Object e) {
        if (i < 0 || i >= size){
            throw new IndexOutOfBoundsException(i + "越界");
        }
        Node pNode = getNode(i);
        Object old = pNode.data;
        pNode.data=e;
        return old;
    }

//    获取指定索引值的元素
    @Override
    public Object get(int i) {
        if (i < 0 || i >= size){
            throw new IndexOutOfBoundsException(i + "越界");
        }
        Node pNode = getNode(i);
        return pNode.data;
    }

//    指定元素前面插入
    @Override
    public boolean insertBefore(Object p, Object e) {
        int index = indexOf(p);
        if (index < 0){
            return false;
        }
        insert(index,e);
        return true;
    }

//    指定元素后面插入
    @Override
    public boolean insertAfter(Object p, Object e) {
        int index = indexOf(p);
        if (index < 0){
            return false;
        }
            insert(index + 1,e);
        return true;
    }

    private class Node{
        private Node prve;
        private Object data;
        private Node next;
        public Node(Node prve, Object data, Node next) {
            this.prve = prve;
            this.data = data;
            this.next = next;
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        Node pNode = first;
        for (Node node = first;node != null;node = node.next) {
            sb.append(node.data);
            if (node != last){
                sb.append(",");
            }
        }
        sb.append("]");
        return String.valueOf(sb);
    }
}
```

### 顺序存储与链式存储的实现线性表的比较

#### 时间上的比较

线性表的基本操作：查询，插入，删除

查询：

>  数组顺序存储，可以直接通过索引值访问每个元素，实现了数组元素的随机访问
>
> 链式存储，每次从头结点或者尾节点依次查找
>
> 如果线性表主要是查询操作，优先原则顺序存储的线性表

插入与删除：

> 数组顺序存储的线性表，在插入删除时，需要移动大量的元素
>
> 链式存储，只需要哦修改节点的前驱后续的指针即可，不需要移动元素
>
> 如果线性表经常使用插入或者删除操作，优先选择链式存储实现的线性表

#### 空间上的比较

顺序存储需要预先分配一块连续的存储空间，在使用过程中会出现连续的存储空间

链式存储的空间是动态分配的，不会浪费空间

如果线性表的长度经常变化，则优先选择链式存储

如果线性表的长度变化不大，优先选择顺序存储，因为链式存储需要额外的存储空间，来存储它的前驱和后继

# 栈与队列

栈与队列从逻辑结构上来看，也是线性结构，是操作首先的线性结构

## 栈

### 栈的特点及抽象数据类型

栈（stack），也称堆栈，是一种操作受限的线性表，栈只允许在线性表的一段插入或删除等操作，

在线性表中进行插入的一端叫做栈顶，栈顶保存的元素被称为栈顶元素，相对的一端称为栈底

如果栈中没有元素，则称为空栈

向栈中插入元素，称为进栈或入栈，从栈中删除元素称为退栈或出栈

由于栈的操作只能在栈顶进行，后进栈的元素必定先出栈，称为后进先出表

<img src="https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210816142754962.png" alt="image-20210816142754962" style="zoom:67%;" />

### 堆栈抽象数据类型的定义

```java
ADT Stack {
    数据对象：D = {a0,a1,a2,a3....}  ax是同一种数据类型
    数据关系：R = {<ai,ai+1>}
    基本操作：
        getSize()	返回元素的个数
        isEmpty()	判断堆栈是否为空
        push(Object)	入栈
        pop()	出栈
        peek()	返回栈顶元素
}
```

#### 栈的顺序实现

顺序栈可以通过数组存储堆栈的元素

堆栈的操作都在栈顶完成，选择数组中索引值较大的一端多为栈顶

```java
public class MyArrayStack implements MyStack {
    private Object [] elements;
    public static final int DEFAULT_CAPACITY = 16;
    private int top;

    public MyArrayStack() {
        elements = new Object[DEFAULT_CAPACITY];
    }

    public MyArrayStack(int initalCapacity) {
        elements = new Object[initalCapacity];
    }

//    元素个数
    @Override
    public int getSize() {
        return top;
    }

//    判断堆栈是否为空
    @Override
    public boolean isEmpty() {
        return top <= 0;
    }

//    入栈
    @Override
    public void push(Object e) {
        if (top >= elements.length){
            Object [] newElements = new Object[elements.length*2];
            for (int i = 0; i < elements.length ; i++) {
                newElements[i] = elements[i];
            }
            elements=newElements;
        }
        elements[top] = e;
        top++;
    }

//    出栈
    @Override
    public Object pop() {
        if (top <= 0){
            throw new StackOverflowError("栈已空");
        }
        top--;
        return elements[top];
    }

//    返回栈顶元素
    @Override
    public Object peek() {
        return elements[top - 1];
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        for (int i = 0; i < top ; i++) {
            sb.append(elements[i]);
            if (i<top-1){
                sb.append(",");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}
```

#### 栈的链式实现

使用链表作为栈的存储结构，有时也成为了链栈

栈只允许在线性表的一端进行操作，可以选择链表的头部作为顶栈

不管是入栈还是出栈都在链表的首节点上进行

```java
package com.zym.Stack;

public class MyLinkStack implements MyStack{

    private Node top;
    private int size;

//    返回堆栈元素的个数
    @Override
    public int getSize() {
        return size;
    }

//    判断堆栈是否为空
    @Override
    public boolean isEmpty() {
        return size <= 0;
    }

//    入栈
    @Override
    public void push(Object e) {
        Node newNode = new Node(e,top);
        top = newNode;
        size++;
    }

//    出栈
    @Override
    public Object pop() {
        if(size < 1){
            throw new StackOverflowError("栈已空");
        }
        Object a = top.data;
        top = top.next;
        size--;
        return a;
    }

//    返回栈顶元素
    @Override
    public Object peek() {
        if (size < 1){
            throw new StackOverflowError("栈已空");
        }
        return top.data;
    }

    private class Node{
        Object data;
        Node next;
        public Node(Object data, Node next) {
            this.data = data;
            this.next = next;
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        for (Node pNode = top;pNode != null;pNode=pNode.next){
            sb.append(pNode.data);
            if (pNode.next != null){
                sb.append(",");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}
```

### 栈的应用

栈的特点：后进先出

#### 进制转换

```java
import com.zym.Stack.MyLinkStack;
import org.junit.Test;

public class TestBaseConversion {

    @Test
    public void test01(){
        System.out.println(convert(100,2));
    }

//    十进制转换为指定的进制
    private String convert(int num,int decimal){
        MyLinkStack stack = new MyLinkStack();
        int remainder = num % decimal;
        while (num != 0){
            stack.push(remainder);
            num = num / decimal;
            remainder = num % decimal;
        }
        StringBuilder sb = new StringBuilder();
        while ( !stack.isEmpty()){
            sb.append(stack.pop());
        }
        return sb.toString();
    }
}
```

#### 检测表达式中的括号是否匹配

假设表达式中的三种括号可以任意嵌套：{[(3+5)\*2]+1}\*3

对于任一个做括号都需要有一个右括号相对应，最早出现的右括号与最早出现的左括号相对应，符合栈的特点

算法：

最早出现的左括号直接入栈，等待右括号。如果是右括号，则判断其与当前站点的左括号是否匹配，如果不匹配，则表达式不合法

如果是右括号，栈已空，则表达式不合法

读完整个表达式，栈不空，说明有左括号没有匹配上，则表达式不合法。  

```java
import com.zym.Stack.MyArrayStack;
import org.junit.Test;

public class TestBracketMath {

    @Test
    public void test(){
        System.out.println(braketMatch("{[(3+5)-1]+3}"));
    }

    public boolean braketMatch(String expression){
        MyArrayStack satck = new MyArrayStack();
        for (int i = 0; i < expression.length() ; i++) {
            char cc = expression.charAt(i);
            switch (cc){
                case '(' :
                    satck.push(cc);
                    break;
                case '[' :
                    satck.push(cc);
                    break;
                case '{' :
                    satck.push(cc);
                    break;
                case ')':
                    if ( !satck.isEmpty() && satck.pop().equals('(')){
                        break;
                    }else {
                        return false;
                    }
                case ']':
                    if ( !satck.isEmpty() && satck.pop().equals('[')){
                        break;
                    }else {
                        return false;
                    }
                case '}':
                    if ( !satck.isEmpty() && satck.pop().equals('{')){
                        break;
                    }else {
                        return false;
                    }
            }
        }
        if (satck.isEmpty()){
            return true;
        }else {
            return false;
        }
    }
}
```

#### 算术表达式的求值

定义两个栈，一个存储运算符，一个存储操作数

读取表达式，如果是操作数就存储到操作数栈，

如果是操运算符：

​		运算符栈为空，直接入栈

​		运算符栈不为空，把运算符中的栈顶运算符与当前操作的运算符进行优先级比较

​				当前运算符优先级高，运算符入栈

​				当前运算符优先级低，弹出栈顶运算符，从操作数栈中弹出两个操作数进行运算，把结果存储到操作数栈

遍历完整个表达式，两个栈都不为空，一次弹出运算符与操作数进行计算，把结果存储到操作数栈中

如果运算符栈不为空，或操作数栈中有多个数，则表达式错误

## 队列

### 队列的特点及抽象数据类型

队列，简称为队，也是一种受限的线性表，只允许在线性表的云端插入，而在表的另一端删除

在插入数据的云端为队尾（rear），在删除数据的云端称为队首（front）

插入数据叫做入队或进队，删除元素叫做出队或离队

特点：先进先出

队列的抽象数据类型：

```java
ADT Queue{
    数据对象：D = {a0,a1,a2...}
    数据关系：R = {<ai,ai+1>}
    数据操作：
        getSize()	返回元素的个数
        isEmpty()	判断堆栈是否为空
        enQueue(e)	入队
        deQueue（）	出队
        peek()	返回队首
}
```

### 队列的顺序存储

![image-20210819115457010](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210819115457010.png)

在队列的实现中，我们可以把数组设想为一个圆环，这种数组称为循环数组，用循环数组实现的队列我们称为循环队列

用front指针指向队首元素所在单元，使用rear指针指向队尾元素所在单元的后一个单元

在元素入队时，将新入队的元素保存在rear指向的单元，然后rear指针后移，

在出队时，将队首指针front指向的元素返回然后front指针后移

一般情况下，采用两种方式不是队列已满：

1. 少用一个存储单元，当队尾指针rear的下一个单元是为首指针front时，停止入队（rear+1）%capacity == front时表示对已满，当front == rear 时表示对为空

   ![image-20210819121549168](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210819121549168.png)

2. 增设一个标志你是对为空还是满，通常用size变量表示元素的个数，当size == 0表示对列为空，size == capacity时表示对已满

![image-20210819121026430](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210819121026430.png)

#### 实现

```java
package com.zym.Queue;

import java.util.Queue;

public class MyArrayQueue {
    private Object[] elements;
    public static final int DEFAULT_CAPACITY = 8;
    private int front;
    private int rear;
    private int size;

    public MyArrayQueue() {
        elements = new Object[DEFAULT_CAPACITY];
    }

    private MyArrayQueue(int initialCapacity){
        elements = new Object[initialCapacity];
    }

    //返回元素的个数
    public int getSize(){
        return size;
    }

//    判断队列是否为空
    public boolean isEmpty(){
        return size==0;
    }

//    入队
    public void enQueue(Object e){

        if (size >= elements.length){
//            如果队列已满，就对其扩容
            expandQueue();
        }

        elements[rear] = e;
        rear = (rear+1)%elements.length;
        size++;
    }
    private void expandQueue(){
        Object [] newelements = new Object[elements.length * 2];
        for (int i = 0; i < size ; i++) {
            newelements[i] = elements[front];
            front = (front +1)%elements.length;
        }
        elements = newelements;
        front = 0;
        rear = size;
    }

//    出队
    public Object deQueue(){
        if (size <= 0){
            throw new QueueEmptyException("队列为空");
        }
        Object old = elements[front];
        front = (front + 1)%elements.length;
        size --;
        return old;
    }

//    返回队首元素
    public Object peek(){
        if (size <= 0){
            throw new QueueEmptyException("队列为空");
        }
        return elements[front];
    }
}

/**
 * 自定义运行时异常：队列为空
 */
class QueueEmptyException extends RuntimeException{
    public QueueEmptyException(){
        super();
    }
    public QueueEmptyException(String message){
        super(message);
    }
}
```

### 队列的链表实现

使用单向链表实现队列

头部作为队首，尾部作为队尾

```java
package com.zym.Queue;

public class MyLinkQueue {

    private Node front;
    private Node rear;
    private int size;

    //返回元素的个数
    public int getSize(){
        return size;
    }

    //    判断队列是否为空
    public boolean isEmpty(){
        return size==0;
    }

    //入队
    public void enQueue(Object e){
        Node newnNode = new Node(e,null);
        if (rear == null){
            front = newnNode;
            rear = newnNode;
        }else {
            rear.next = newnNode;
            rear = newnNode;
        }
    }

    //出队
    public Object deQueue(){
        if (size == 0){
            throw new QueueEmptyException2("队为空");
        }
        Object old = front.element;
        front = front.next;
        if (front == null){
            rear = null;
        }
        return old;
    }

//    返回队首元素
    public Object peek(){
        if (size == 0){
            throw new QueueEmptyException2("队为空");
        }
        return front.element;
    }

//    通过内部类表示单向链表的节点
    private class Node{
        Object element;
        Node next;
        public Node(Object element, Node next) {
            this.element = element;
            this.next = next;
        }
    }
}
/**
 * 自定义运行时异常：队列为空
 */
class QueueEmptyException2 extends RuntimeException{
    public QueueEmptyException2(){
        super();
    }
    public QueueEmptyException2(String message){
        super(message);
    }
}
```

# 树

## 树的定义

树是有一个集合及该集合上定义的一种关系构成的，集合中的元素称为树的节点，定义的关系称为父子关系，分支关系的树的节点之间建立一个层次结构

树的递归定义：

树（Tree）是有 n（n>=0）个节点组成的有限集

当 n=0 时，称树为空，不包含任何节点，

当 n>0 时，就是一颗非空树，

>  有且仅有一个特定的称为根的节点（root）
>
> 当 n>1 时，其他的节点可以分为 m（m>0）个互不相交的有限集 T1,T2...，其中每一个有限集本省又是一棵树，称为根节点的子树

<img src="https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210820142303950.png" alt="image-20210820142303950" style="zoom: 67%;" />

如图右侧，节点A是根节点，它包含T1和T2两棵子树，T1=(BDGHI)，T2=(CEF)，每棵子树又是一棵树，在T1子树中，B是根节点，在T2子树中，C是根节点

**注意：**

当n>0时，在飞空树中，根节点是唯一的

当m>0时，在某个节点的子树是没有限制的，并且各个子树肯定是不相交的

## 相关概念

节点拥有的子树的数量称为节点的度（Degree）

度为0的节点称为叶子节点（Leaf）或者终端节点，度不为0的节点称为分支节点或非终端节点

处了根节点外，分支节点也称为内部节点

树的度是树内各节点中度的最大值

例如上图右侧：

> A是根节点
>
> BCDE称为内部节点
>
> FGHIJ称为叶子节点
>
> AC节点的度为2，BE节点的度为1，D节点的度为3，FGHIJ节点的度为0
>
> 树的度为 ：3

节点的子树的跟称为该节点的孩子（Child），相对应的该节点称为孩子节点的双亲节（Paren）点或父节点

父子节点之间的连线是树的一条边，树中的节点数等于树的边树加1

在树中，根节点没有双亲节点，其他节点都有并且只有一个父节点，每个节点可以有多个孩子节点

同一个双亲孩子之间互称为兄弟（Sibling）

节点的祖先是从根节点到该节点所经过的分支上的所有的节点

以某节点为跟的子树上的节点都称为该节点的子孙

## 节点的层次

节点的层次（Level）是从根节点开始，根为第一层，根的孩子为第一层，以此类推

有人把根的层次从第0层开始算

如果某节点在第i层，则其子树的跟肯定在 i+1 层

双亲节点在同一层次上的节点护卫堂兄弟

树中节点的最大层次称为树的深度（Depth）或高度，当前树的高度是4

在树中 k+1个节点通过 k 条边构成的序列长度为 k 的路径

> {(D,B),(B,A),(A,C),(C,E)}构成了一条连接D节点与E节点的路径，该路径的长度为4
>
> 在树当中任意两个节点都有唯一的路径，从根节点开始，存在到其他任意节点的唯一路径

## 有序树和无序树

如果将树的节点的各个子树看做是从左到右有顺序的，不能互换的，则称该树为有序树，否则为无序树

如果不特殊说明，一般是有序树

树的度为 m 的有序树称为 m 叉树

森林（Forest）是 m （m>=0）棵互不相交的树的集合，对树的每个节点而言，其子树的集合就是森林，删去树的根就得到一个森林，反之，给森林加上一个根就变成一棵树

## 树的抽象数据类型的定义

```java
ADT Tree{
    数据对象：D      D是具有相同性质的数据元素的集合
    数据关系：R      如果D为空，则R也为空；如果D不为空，D中存在唯一一个被称为根的元素root，该元素没有前驱；除了根元素外，D中的					每一个元素都有且只有一个前驱
    数据操作：
        getSize()	返回元素的个数
        getroot()   返回树的根元素
        getParent(x)   返回x节点的父节点
        getFirstChild(x)   返回x节点的第一个孩子
        getNextSibling(x)   返回x节点的下一个兄弟节点，如果x是最后一个孩子，返回null
        getHeight(x)   返回以x节点为跟的树的高度
        insertChild（x,child）   将节点child为跟的子树插入到当前树中，作为x节点的孩子
        deleteChild(x,i)   删除节点x的第i可=棵子树
        preOrder(x)   先序遍历x为根的树
        postOrder(x)   后序遍历x为根的树
        levelOrder(x)   层次遍历x为根的树
}
```

## 树的存储结构

### 双亲表示法

树中的节点，除了跟节点外，可以在使用数组存储书中的每个节点，数组的下标就是数组的位置指针，每个节点再增加一个纸箱双亲的节点，节点的结果可以定义为：

![image-20210821085600895](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210821085600895.png)

使用该方式存储树的结果为：

![image-20210821090211142](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210821090211142.png)

在双亲表示法中，可以通过parent指针域找到该节点的父节点，如果要找某个节点的孩子节点，需要遍历整个数组

可以在节点中增加长子域，指向第一个孩子的指针域，没有孩子的长子域设置为 -1

![image-20210821090649398](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210821090649398.png)

还可以扩展兄弟域等

### 孩子表示法

树中的每个节点可以有多可子树，可以考虑使用多重链表，每个子节点可以有多个指针域，每个指针域指向他的子树的根节点，把这种方法称为多重链表表示法

树的每个节点的度可能不一样，即每个节点的孩子数可能不相等，一般设计两种方案：

方案一：

> 节点中指针域的个数就是数的度（树中节点最多的孩子数）
>
> ![image-20210821092916723](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210821092916723.png)
>
> 树中的各个节点的度相差很大时，很浪费空间，后很多节点的指针域是空的，这种表示方法适合树的各个节点度相差很少的情况

方案二：

> 每个节点的指针域的个数等于该节点的度，在节点中专门定义一个储存该节点度的域
>
> 如：节点可以设计为
>
> ![image-20210821093848523](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210821093848523.png)
>
> 这种方法提高了空间的利用率，但各个节点的结果可能不一样，还要维护节点的度的值，会增加时间上的损耗
>
> 可以定义一个线性表来存储树中的所有节点的信息，我们称为节点表，每一个节点建立一个孩子表，孩子表值存储孩子节点在数组中的存储位置由于每个节点的孩子节点是不确定的，经常使用一个链表来表示孩子之间的关系

方案三：

> 在这种表示方法中，需要设计两种节点，一个节点表示数组中的表头节点，包括数据域和指向第一个孩子的指针域
>
> 还需要设计一个孩子节点，存储孩子节点在数组的下标和指向下一个节点孩子的指针
>
> 在这种结构中，我们可以发表的查找某个节点的孩子，也可以发表的查找某一个节点的兄弟，只需要访问这个节点的孩子的链表就可以了
>
> 如果需要查找节点的父节点，还需要遍历整棵树
>
> ![image-20210821095432838](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210821095432838.png)
>
> 我们可以在节点表中，即数组中的节点增加一个指向父节点的指针，如：（双亲孩子表示法）
>
> ![image-20210821100540029](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210821100540029.png)

### 孩子兄弟表示法

从树节点的兄弟的角度来确定树的存储结构

对于任意一棵树，它的节点的第一个孩子如果存在，肯定是唯一的，如果节点的右兄弟存在，也肯定是唯一的，可以设置两个指针，分别指向某个节点的第一个孩子节点和他的右兄弟，如

![image-20210821101814760](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210821101814760.png)

在这种表示方法中可以方便的查找某个节点的孩子和右兄弟，这种方法可以把一颗复杂的树转换为二叉树

## 二叉树

二叉树（Binary Tree）是有n个节点组成的集合，该集合要么是一个空集合，要么是一个由根节点和两棵互不相交的子树组成，左边的叫左子树，右边的叫右子树

### 特点：

> 每个节点最多有两棵子树
>
> 左子树与右子树是有顺序的
>
> 即使树中的某个节点只有一颗子树，也是区分左子树和右子树的

### 二叉树的五种基本形态：

空二叉树

只有一个节点的二叉树

根节点只有左子树

根节点只有右子树

根节点即有左子树又有右子树

### 特殊的二叉树

**斜树：**

所有节点都只有左子树的二叉树称为左斜树，所有节点都只有右子树的二叉树称为右斜树

**满二叉树：**

在一颗二叉树中如果所有的分支节点都有左子树后右子树，并且所有的叶子节点都在同一层上，这样的二叉树称为满二叉树

![image-20210822100930825](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210822100930825.png)

满二叉树的特点：

>  叶子节点只能出现在最下面一层
>
> 非叶子节点的度一定是2
>
> 同样深度的二叉树中，满二叉树的节点数一定是做多的，叶子节点也是最多的

**完全二叉树：**

一颗具有n个节点的二叉树按层次编号，如果编号为i的节点与同样深度的满二叉树编号为i的节点在二叉树中的位置完全相同，这就是棵完全二叉树

就是把满二叉树最下层从最右侧开始去电若干相邻的叶子节点

![image-20210822101645724](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210822101645724.png)![image-20210822101721826](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210822101721826.png)

完全二叉树的特点：

> 叶子节点只能出现在下两层
>
> 最下层的叶子节点集中出现在左侧连续的位置
>
> 倒数第二层的叶子节点一定是在右边连续的位置
>
> 同样节点数的二叉树，完全二叉树的深度最小

### 二叉树的性质

- 在二叉树的第i层上，最多有 2 ^i-1^ 个节点（1>=1）

- 深度为k的二叉树最多有 2 ^k^ -1 个节点

- 对于任意一颗二叉树，叶子节点的数量 n~0~，度为2的节点数量n~2~，则n~0~=n~2~+1（叶子节点数始终比度为2的节点数多一个）

- 节点之间连线（分支线）的数量 = 节点的总数 - 1

- 具有n个节点的完全二叉树深度为 floor(log~2~n)+1 

  满二叉树如果善妒为 k ，节点的总数量为 2^k^-1 ，如果把总结点树记为 n ，即 n = 2^k^-1，则 k = log~2~(n+1)

  深度为 k 的完全二叉树节点数量 n 一定小于同样深度的满二叉树的节点数量，一定大于深度为 k-1 的满二叉树的节点数，即

   2^k-1^-1<n<=2^k^-1			n就是深度为k的完全二叉树节点的数量

  n<=2^k^-1	意味着	n<2^k^

  n > 2^k-1^-1	意味着	2^k-1^<= n

  即	2^k-1^<=n<2^k^	对不等式的两边取对数，得到 k-1 <=log~2~n <k

  因为k是深度，也是一个整数， floor(log~2~n)+1 

  floor(xxx) 是指小于等于 xxx 的最大整数

- 对于一个完全二叉树进行层次编号

  ![image-20210822113456362](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210822113456362.png)

  对于任意一个节点 i 有：

  > 如果 i==1，则节点 i 是二叉树的根，如果 i>1，则该节点的双亲节点是 i/2
  >
  > 如果 2\*i>n ，则该节点 i 没有左孩子，否则左孩子是 2\*i
  >
  > 如果 2\*i+1>n ，则该节点 i 没有右孩子，否则左孩子是 2\*i+1

###  二叉树的存储结构

#### 二叉树的顺序存储

使用因为数组存储二叉树中的节点，节点的存储位置（数组的下标）可以反映节点之间的逻辑关系

**完全二叉树的顺序存储：**

![image-20210822114242465](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210822114242465.png)

将完全二叉树存储到数组中，数组的下边对应存储位置

![image-20210822114532843](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210822114532843.png)

对于不是完全二叉树的情况，也可以将二叉树进行编号，将不存在的节点设置为null

![image-20210822115139451](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210822115139451.png)

如果二叉树中有很多不存在的节点，就会造成存储空间的浪费，一般情况下，顺序存储只用于完全二叉树

#### 二叉树的链式存储

二叉树的节点最多有两个盖子，可以为节点设计一个数据域，一个指向左孩子的和一个指向右孩子的指针域，这样的节点组成的链表称为二叉链表

二叉树节点的结构可以设计为：

![image-20210823093336819](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210823093336819.png)

以下二叉树的二叉链表为：

![image-20210822114242465](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210822114242465.png)![image-20210823095211725](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210823095211725.png)

为了方便找到父节点，我们可以在节点上增加一个指向父节点的指针域，这种节点组成的链表我们称为三叉链表，节点的结构可以设计为：

![image-20210823094834434](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210823094834434.png)

#### 使用三叉链表定义二叉树

```java
package com.zym.tree;

public class BinaryTreeNode {
    private Object data;    //数据域
    private BinaryTreeNode parent;  //父节点
    private BinaryTreeNode lchild;  //左孩子
    private BinaryTreeNode rchild;  //右孩子
    private int height; //以当前节点为根的二叉树的高度
    private int size;   //以当前节点为根的二叉树的所有节点数量

    /******************构造方法*********************/
//    根据指定的数据创建节点
    public BinaryTreeNode(Object e){
        data = e;
        parent = null;
        lchild = null;
        rchild = null;
        height = 1;
        size = 1;
    }

    public BinaryTreeNode() {
        this(null);
    }

    /***********************判断当前节点的情况**************************/
//    判断是否有父节点
    public boolean hasParent(){
        return parent != null;
    }
//    判断是否有左孩子
    public boolean hasLChild(){
        return lchild != null;
    }
//    判断是否有右孩子
    public boolean hasRChild(){
        return rchild != null;

    }
//    判断是否是叶子节点
    public boolean isLeaf(){
        return lchild != null && rchild != null;
    }
//    判断是否为父节点的左孩子
    public boolean isLChild(){
        return parent != null && parent.lchild == this;
    }
//    判断是否为父节点的右孩子
    public boolean isRChild(){
        return parent != null && parent.rchild == this;
    }

    /***************************与heigth高度相关的操作**************************/
//    返回高度
    public int getHeight(){
        return height;
    }
//    更新当前节点的高度，以及祖先节点的高度
    public void updateHeight(){
        int newHeight = 0;
        //当前节点的高度为左子树的高度或者右子树的高度，最大值+1
        if (hasLChild()){
            newHeight = Math.max(newHeight,getLchild().getHeight()+1);
        }
        if (hasRChild()){
            newHeight = Math.max(newHeight,getRchild().getHeight()+1);
        }
        //如果当前节点的高度有变化，递归更新其祖先节点的高度
        if (newHeight == height){
            return;
        }
        height = newHeight;
        if (hasParent()){
            getParent().updateHeight();
        }
    }
    
    /********************与size节点个数的相关操作********************/
//    返回当前节点为根的二叉树的节点数
    public int getSize() {
        return size;
    }
//    更新当前节点及祖先的节点数
    public void updateSize(){
        size = 1;   //当前节点本身
        //累加左子树的节点数
        if (hasLChild()){
            size += getLchild().getSize();
        }
        if (hasRChild()){
            size += getRchild().getSize();
        }
        //递归更新祖先节点数
        if (hasParent()){
            getParent().updateSize();
        }
    }
    
    /****************************与父节点相关的操作**********************************/
//    返回父节点
    public BinaryTreeNode getParent(){
        return parent;
    }
//    断开与父节点的关系
    public void disInheritence(){
        if ( !hasParent()){
            return;
        }
        //如果当前节点是其父节点的左孩子
        if (isLChild()){
            parent.lchild = null;
        }else if (isRChild()){
            parent.rchild = null;
        }
        parent.updateHeight();
        parent.updateSize();
        parent = null;
    }
    
    /*********************************与左孩子相关的操作**********************************/
//    返回左孩子
    public BinaryTreeNode getLchild(){
        return lchild;
    }
//    设置当前节点的左孩子，把原来的左孩子返回
    public BinaryTreeNode setLChild(BinaryTreeNode newLChild ){
        BinaryTreeNode old = this.lchild;
        if (hasLChild()){
            getLchild().disInheritence();
        }
        //设置新的左孩子为参数节点
        if (newLChild != null){
            newLChild.disInheritence();
            this.lchild=newLChild;
            newLChild.parent=this;
            this.updateSize();
            this.updateHeight();
        }
        return old;
    }

    /*********************************与左孩子相关的操作**********************************/
//    返回右孩子
    public BinaryTreeNode getRchild(){
        return rchild;
    }
    //    设置当前节点的右孩子，把原来的右孩子返回
    public BinaryTreeNode setRChild(BinaryTreeNode newRChild ){
        BinaryTreeNode old = this.rchild;
        if (hasRChild()){
            getRchild().disInheritence();
        }
        //设置新的右孩子为参数节点
        if (newRChild != null){
            newRChild.disInheritence();
            this.rchild=newRChild;
            newRChild.parent=this;
            this.updateSize();
            this.updateHeight();
        }
        return old;
    }
}
```

### 二叉树的遍历

从根节点出发，按照某种次序，一次访问二叉树中的所有节点，是的每个节点被访问且只访问一次

按照节点被访问的次序，可以得到由二叉树所有节点组成的一个序列

1. 前序遍历

   先序遍历，先根序遍历，DLR（Data，LChild，RChild）

   如果二叉树为空，则是空操作，分支线访问根节点，前序遍历左子树，前序遍历右子树

   ![image-20210824102100338](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824102100338.png)

2. 中序遍历，LDR

   如果二叉树为空，则是空操作，否则，先序遍历左子树，访问根节点，终须遍历右子树

   ![image-20210824102918475](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824102918475.png)

3. 后续遍历

   后根序遍历，LRD

   如果二叉树为空，则空操作，否则，后续遍历左子树，后续遍历右子树，访问根

   ![image-20210824103454488](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824103454488.png)

4. 二叉树的层序遍历

   从树的第一层开始，即从根节点开始访问，从上到下逐层遍历，在同一层中按从左到右的顺序对节点逐个访问

   ![image-20210824103955462](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824103955462.png)

### 二叉树遍历练习

已知一棵二叉树的前序遍历序列为：ABCDEF，中序遍历序列为：CBAEDF，问二叉树的后续遍历序列是什么？

CBEFDA

![image-20210824105713392](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824105713392.png)

### 代码实现二叉树的先序遍历

```java
package com.zym.tree;

import java.util.LinkedList;

/**
 * 使用三叉链表创建二叉树
 */
public class BinaryTree {
    private BinaryTreeNode root;

    public BinaryTree(BinaryTreeNode root) {
        this.root = root;
    }

//    返回元素的个数
    public int getSize(){
        if (root == null){
            return 0;
        }
        return root.getSize();
    }

//    判断二叉树是否为空
    public boolean isEmpty(){
        return getSize() == 0;
    }

//    返回根节点
    public BinaryTreeNode getRoot(){
        if (root != null){
            return root;
        }
        return null;
    }

//    返回树的高度
    public int getHeight(){
        if (root == null){
            return 0;
        }
        return root.getHeight();
    }

    /********************二叉树的先序遍历*******************/
    private void preOrderRecusion(BinaryTreeNode root,LinkedList<Object> list){
        if (root == null){
            return;
        }
        //先访问根节点
        list.add(root.getData());
        //递归，先序遍历左子树
        preOrderRecusion(root.getLchild(),list);
        //递归，先序遍历右子树
        preOrderRecusion(root.getRchild(),list);
    }

//    打印当前二叉树的先序遍历序列
    public void preOrder(){
        LinkedList<Object> list = new LinkedList<>();
        preOrderRecusion(root,list);
        System.out.println(list);
    }

    /***************二叉树的中序遍历************/
    private void inOrderRecursion(BinaryTreeNode root,LinkedList<Object> list){
        if (root == null){
            return;
        }
        inOrderRecursion(root.getLchild(),list);
        list.add(root.getData());
        inOrderRecursion(root.getRchild(),list);
    }
    public void inOrder(){
        LinkedList<Object> list = new LinkedList<>();
        inOrderRecursion(root,list);
        System.out.println(list);
    }

    /***************二叉树的后序遍历************/
    private void posOrderRecursion(BinaryTreeNode root,LinkedList<Object> list){
        if (root == null){
            return;
        }
        posOrderRecursion(root.getLchild(),list);
        posOrderRecursion(root.getRchild(),list);
        list.add(root.getData());
    }
    public void posOrder(){
        LinkedList<Object> list = new LinkedList<>();
        posOrderRecursion(root,list);
        System.out.println(list);
    }

    /******************二叉树的层序遍历*****************/
    private void levelOrderTranverse(BinaryTreeNode root,LinkedList<Object> list){
        if (root == null){
            return;
        }
        LinkedList<BinaryTreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
            BinaryTreeNode node = queue.poll();
            list.add(node.getData());
            if (node.hasLChild()){
                queue.offer(node.getLchild());
            }
            if (node.hasRChild()){
                queue.offer(node.getRchild());
            }
        }
    }
    public void levelOrder(){
        LinkedList<Object> list = new LinkedList<>();
        levelOrderTranverse(root,list);
        System.out.println(list);
    }
}
```

# 算法及性能分析

 ## 算法是什么

算法就是为解决某一特定问题而规定的一系列特定的操作，是一组有序的指令的集合

评价一个算法的好坏，实际上就是评价算法的资源占用率，计算机最重要的资源就是时间和空间

我们使用时间复杂度衡量程序运行需要的时间，使用空间复杂度衡量程序所占内存的大小

### 算法的五个特性

输入：一个算法有 0 或多个输入

输出：至少有一个输出，没有输出的算法是没有意义的

有穷性：算法中执行的指令的个数应该是有限的，

确定性：对于特定的合法输入它的输出应该是唯一的

可行性：算法能够实现，并且需要在有限的时间内完成

### 算法的设计要求

正确性：没有语法错误，对于合法的输入产生满足要求的输出，对于特定的输入也能够产生正确的输出

可读性：算法的另一个目的是为了交流，方便阅读

健壮性：对于不合理的要求也能够给出合理的提示信息，而不是崩溃

时间效率高于存储空间小

## 时间复杂度

讨论计算机程序运行的时间可以采用以下的办法：

**事后统计**

​	编程实现这个算法，统计所需要的时间

**事前分析**

​	采用渐进时间复杂度分析估算

### 渐进时间复杂度

渐进时间复杂度，简称时间复杂度，在进行算法分析时，语句总的执行数记作 T(n)，是关于问题规模 n 的函数，分析 T(n) 随着问题规模 n 的变化，确定 T(n) 的数量级

T(n) = O(f(n))   表示随着问题规模的增大，算法执行的时间增率和 f(n) 函数的增长率相同， f(n) 是问题规模n的一个函数

随着输入规模 n 的增大，T(n) 增长越慢的算法越好

## 算法时间复杂度分析

### 算法一：

计算 1+2+3+4+....+n的累加，高斯算法

```java
public static Integer sum2(Integer n){
    return n * (n+1) /2;
}
```

顺序执行，时间复杂度，T(n)=O(1)，是常数阶

### 算法二：

计算 1+2+3+4+....+n的累加

```java
    public static Integer sum1(Integer n){
        Integer sum = 0;
        for (int i = 0; i <= n; i++) {
            sum += i;
        }
        return sum;
    }
```

T(n) = O(n)，线性阶

## 空间复杂度

为了求解某一问题，在执行操作期间所需要的空间大小，不包含用来存储输入所需要的空间

记作：S(n)=O(f(n))

结论：算法的空间复杂度是以时间复杂度为上线的

