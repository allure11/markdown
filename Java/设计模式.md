# 设计模式七大原则

## 设计模式的目的

​	编写软件过程中，程序员面临着来自**耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性**等多方面的挑战，设计模式是为了让程序(软件)，具有更好

- **代码重用性**(即:相同功能的代码，不用多次编写)
- **可读性**(即:编程规范性，便于其他程序员的阅读和理解)
- **可扩展性**(即:当需要增加新的功能时，非常的方便，称为可维护)
- **可靠性**(即:当我们增加新的功能后，对原来的功能没有影响)
- 使程序呈现**高内聚，低耦合**的特性

分享金句:

1. 设计模式包含了面向对象的精髓，“懂 了设计模式，你就懂了面向对象分析和设计(O0AD)的精要”。
2. ScottMayers在其巨著《EffectiveC++》 就曾经说过: C++老手和C++新手的区别就是前者手背上有很多伤疤。

## 设计模式七大原则

设计模式原则，其实就是**程序员在编程时，应当遵守的原则**，也是各种**设计模式的基础**(即:**设计模式为什么这样设计的依据**)。

设计模式常用的七大原则有:

- 单一职责原则
- 接口隔离原则
- 依赖倒转(倒置)原则
- 里氏替换原则
- 开闭原则
- 迪米特法则
- 合成复用原则

### 单一职责原则


#### 基本介绍（Single responsibility principle）

对类来说的，**即一个类应该只负责一项职责**。 如类A负责两个不同职责:职责1,职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。

#### 单一职责原则注意事项和细节

1. 降低类的复杂度，一个类只负责一项职责。
2. 提高类的可读性，可维护性。
3. 降低变更引起的风险。
4. 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责 原则。

### 接口隔离原则


#### 基本介绍（Interface Segregation Principle）

1. 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。
2. 先看一张图：![image-20210820164304695](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210820164304695.png)
3. 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口那么类B和类D必须去实现他们不需要的方法。
4. 按隔离原则应当这样处理:
       **将接口Interface1**拆分为**独立的几个接口**，类A和类C分别与他们需要的接口建立依赖关系。也就是采用**接口隔离原则。**
5. 接口隔离原则类图：![image-20210820161710705](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210820161710705.png)


### 依赖倒转原则

#### 基本介绍（Dependence Inversion Principle）

依赖倒转原则是指：

1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象。
2. **抽象不应该依赖细节，细节应该依赖抽象**。
3. 依赖倒转(倒置)的中心思想是**面向接口编程。**
4. 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。
5. 使用**接口或抽象类**的目的是制定好**规范**，而不涉及任何具体的操作，把**展现细节的任务交给他们的实现类**去完成。

#### 依赖倒转原则的注意事项和细节

1. **低层模块尽量都要有抽象类或接口**，或者两者都有，程序**稳定性**更好。
2. 变量的**声明类型尽量是抽象类或接口**,这样我们的变量引用和实际对象间，就存在**一个缓冲层**，利于程序扩展和优化。
3. 继承时遵循**里氏替换原则**。

#### 依赖传递的三种方式

- 接口传递
- 构造方法传递
- setter方法传递


### 里氏替换原则

#### 基本介绍(Liskov Substitution Principle)

1. 里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的。
2. 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，**所有引用基类的地方必须能透明地使用其子类的对象**。
3. 在使用继承时，遵循里氏替换原则，在子类中<span style="color:red">**尽量不要重写父类的方法**</span>。
4. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以**通过聚合，组合，依赖来解决问题**。

#### 中的继承性的思考和说明

1. 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。
2. **继承在给程序设计带来便利的同时，也带来了弊端**。比如使用继承会给程序带来**侵入性**，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。
3. 问题提出：在编程中，如何正确的使用继承?  => <span style="color:red">**里氏替换原则**</span>

#### 解决方法

1. 我们发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。
2. 通用的做法是：**原来的父类和子类都继承一个更通俗的基类**，原有的继承关系去掉，**采用依赖，聚合，组合等关系代替**。
3. 组合关系类图![image-20210823164925314](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210823164925314.png)


### 开闭原则

#### 基本介绍(Open Closed Principle)

1. 开闭原则是编程中**最基础、最重要**的设计原则。
2. 一个软件实体如类，模块和函数应该对**扩展开放(对提供方)**，对**修改关闭(对使用方**)。用抽象构建框架，用实现扩展细节。
3. 当软件需要变化时，尽量**通过扩展**软件实体的行为来实现变化，而**不是通过修改**已有的代码来实现变化。
4. 编程中遵循其它原则，以及使用设计模式的目的就是**遵循开闭原则(OCP)**。


### 迪米特法则

#### 基本介绍(Demeter Principle)

1. 一个对象应该对其他对象保持最少的了解。
2. 类与类关系越密切，耦合度越大。
3. 迪米特法则又叫**最少知道原则**，即一个类对**自己依赖的类**知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都**尽量将逻辑封装在类的内部**。对外除了提供的public方法，不对外泄露任何信息。
4. 迪米特法则还有个更简单的定义：只与**直接的朋友通信**。
5. <span style="color:red">**直接的朋友**</span>：每个对象都会与其他对象有耦合关系，只要两个对象之间有**耦合关系**，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现**成员变量，方法参数，方法返回值**中的类为直接的朋友，而出现在**局部变量中的类不是直接的朋友**。也就是说，陌生的类最好**不要以局部变量的形式出现在类的内部**。

#### 迪米特法则注意事项和细节

1. 迪米特法则的核心是**降低类之间的耦合**。
2. 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系。


### 合成复用原则

#### 基本介绍(Composite Reuse Principle)

原则是尽量使用**合成/聚合**的方式，**而不是使用继承**。如果只是为了使用方法，就没必要去继承。

继承![image-20210824160742848](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824160742848.png)

依赖![image-20210824160758451](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824160758451.png)

聚合![image-20210824160812194](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824160812194.png)

组合![image-20210824160907351](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824160907351.png)

## 设计原则核心思想

1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
2. 针对接口编程，而不是针对实现编程。
3. 为了交互对象之间的**松耦合设计而努力**。



# UML类图

## UML基本介绍

1) UML--Unified modeling language UML(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果。
2) UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等。
3) 使用UML来建模，常用的工具有RationalRose ，也可以使用一些插件来建模。<img src="https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824162033632-16297932722251.png" alt="image-20210824162033632" style="zoom: 67%;" />

## UML图

画UML图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML图分类:

1. 用例图(use case)。
2. 静态结构图：<span style="color:red">**类图**</span>、对象图、包图、组件图、部署图。
3. 动态行为图：交互图(时序图与协作图)、状态图、活动图。

说明:

1. **类图**是描述类与类之间的关系的，**是UML图中最核心的**。
2. 在讲解设计模式时我们必然会使用类图，为了能够把设计模式学到位，需要先了解类图。

## UML类图

### 类图基本介绍

1. 用于描述系统中的**类(对象)本身的组成和类(对象)之间的各种静态关系**。

2. 类之间的关系：<span style="color:red">**依赖、泛化(继承)、实现、关联、聚合与组合**</span>。

3. 类图简单举例：

    ```Java
    public class Person{ //代码形式->类图
        private Integer id;
        private String name;
        public void setName(String name){
            this.name=name;
        }
        public String getName(){
            return name;
        }
    }
    ```

    **对应类图：**![image-20210824164132016](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824164132016.png)

### 类图--依赖关系(Dependence)

只要是在<span style="color:red">**类中用到了对方**</span>，那么他们之间就**存在依赖关系**。如果没有对方，连编绎都通过不了。

```java
public class PersonServiceBean {
    private PersonDao personDao;// 类
    
    public void save(Person person) {
    }
    
    public IDCard getIDCard(Integer personid) {
    	return null;
    }
    public void modify() {
    	Department department = new Department();
    }
}
```

**对应类图：**![image-20210824170728624](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824170728624.png)

**小结：**

1. 类中用到了对方
2. 如果是**类的成员属性**
3. 如果是**方法的返回类型**
4. 是方法的**接收的参数类型**
5. 方法中**使用到**

### 类图--泛化关系(ganeralization)

泛化关系**实际上就是继承关系**，他是<span style="color:red">**依赖关系的特例**</span>。

```java
public abstract class DaoSupport {
    public void save(0bject entity){
    }
    public void delete(0bject id){
    }
}

public class PersonServiceBean extends DaoSupport {
}
```

**对应类图：**![image-20210824171602003](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824171602003.png)

**小结：**

1. 泛化关系实际上就是**继承关系**
2. 如果A类继承了B类，我们就说A和B存在泛化关系

### 类图--实现关系(Implementation)

实现关系**实际上就是A类实现B类接口**，他们是<span style="color:red">**依赖关系特例**</span>。

```java
public interface PersonService {
    public void delete(Integer id);
}

public class PersonServiceBean implements PersonService {
	public void delete(Integer id){}
}

```

**对应类图：**![image-20210824172453071](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824172453071.png)

### 类图--关联关系(Association)

1. 关联关系实际上就是**类与类之间的联系**，他是<span style="color:red">**依赖关系的特例**</span>。
2. 关联具有<span style="color:red">**导航性**</span>：即双向关系或单向关系
3. 关系具有多重性：如“1”(表示有且仅有一个)，“0...” (表示0个或者多个)，“0，1”(表示0个或者一个)，“n...m"(表示n到m个都可以),"m...*”(表示至少m个)。

**单向一对一关系：**

```Java
public class Person {
	private IDCard card;
}

public class IDCard{}
```

**对应类图：**![image-20210824175849939](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824175849939.png)

**双向一对一关系：**

```Java
public class Person {
	private IDCard card;
}

public class IDCard{
	private Person person;
}
```

**对应类图：**![image-20210824180144381](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824180144381.png)

### 类图--聚合关系(Aggregation)

聚合关系表示的是**整体和部分**的关系，<span style="color:blue">**整体与部分可以分开**</span>。<span style="color:red">**聚合关系是关联关系的特例**</span>，所以**他具有关联的导航性与多重性**。

如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：

```Java
public class Computer{
    private Mouse mouse;
    private Monitor monitor;
    public vold setMouse(Mouse mouse){
    	this.mouse = mouse;
    }
    public void setMonitor(Monitor monitor){
    	this.monitor=monitor;
    }
}
```

**对应类图：**![image-20210824181100258](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824181100258.png)

### 类图--组合关系(Composition)

组合关系：也是整体与部分的关系，但是<span style="color:blue">**整体与部分不可以分开**</span>。

再看一个案例：在程序中我们定义实体: Person与IDCard、 Head，那么Head和
Person就是组合，IDCard 和Person就是聚合。

```Java
public class Person{
    private IDCard card;
    private Head head = new Head();
}

public class IDCard{}
public class Head{}
```

**对应类图：**![image-20210824181809851](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210824181809851.png)

但是如果在程序中Person实体中定义了对IDCard进行<span style="color:red">**级联删除**</span>，即删除Person时连同IDCard起删除，那么IDCard和Person就是组合了。



# 设计模式概述

## 掌握设计模式的层次

1. 第1层：刚开始学编程不久，听说过什么是设计模式。
2. 第2层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己却不知道。
3. 第3层：学习过了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的。
4. 第4层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的好处。
5. 第5层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来。

## 设计模式介绍

1. 设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式(Design pattern)代表了<span style="color:red">**最佳的实践**</span>。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
2. 设计模式的本质提高**软件的维护性，通用性和扩展性，并降低软件的复杂度**。
3. <<**设计模式**>>是经典的书，作者是Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design (俗称“四人组GOF”)。
4. 设计模式并不局限于某种语言，java， php, C++都有设计模式。

## 设计模式类型

<span style="color:blue">**设计模式分为三种类型，共23种**</span>

1. **创建型模式：**<span style="color:red">**单例模式**</span>、抽象工厂模式、原型模式、建造者模式、<span style="color:red">**工厂模式**</span>。
2. **结构型模式：**适配器模式、桥接模式、<span style="color:red">**装饰模式**</span>、组合模式、外观模式、享元模式、<span style="color:red">**代理模式**</span>。
3. **行为型模式：**模版方法模式、命令模式、访问者模式、迭代器模式、<span style="color:red">**观察者模式**</span>、中介者模式、备忘录模式、解释器模式(Interpreter模式)、状态模式、策略模式、职责链模式(责任链模式)。



# 设计模式23种

## 单例设计模式(重点)

### 单例设计模式介绍

所谓类的单例设计模式，就是采取一 定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)。

比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的， 一般情况下，一个项目通常只需要一个SessionFactory就够，这是就会使用到单例模式。

### 单例模式八种方式

单例模式有八种方式(<span style="color:red">红色</span>为推荐使用)：

- <span style="color:red">饿汉式(静态常量)</span>
- <span style="color:red">饿汉式(静态代码块)</span>
- 懒汉式(线程不安全)
- 懒汉式(线程安全，同步方法)
- 懒汉式(线程安全，同步代码块)
- <span style="color:red">双重检查</span>
- <span style="color:red">静态内部类</span>
- <span style="color:red">枚举</span>

### 饿汉式(静态常量)

饿汉式(静态常量)应用实例
步骤如下:

1. 构造器私有化(防止new)

2. 类的内部创建对象

3. 向外暴露一个静态的公共方法，getInstance

4. 代码实现：

    ```Java
    //饿汉式(静态变量) 这种单例模式可用，可能造成内存浪费
    class Singleton {
        //1.构造器私有化，外部不能new
        private Singleton() {}
        //2.本类内部创建对象实例
        private final static Singleton instance = new Singleton();
        //3.提供一个公有的静态方法，返回实例对象
        public static Singleton getInstance() {
            return instance;
        }
    }
    ```

**优缺点说明：**

1. 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同
    步问题。
2. 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。
3. 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式(或者其他的静态方法)导致类装载，这时候初始化instance就没有达到lazy loading的效果。
4. 结论：这种单例模式**可用，可能**造成内存浪费。

### 饿汉式(静态代码块)

- 代码演示：

    ```Java
    //饿汉式(静态代码块) 这种单例模式可用，可能造成内存浪费
    class Singleton {
        //1.构造器私有化，外部不能new
        private Singleton() {}
        //2.本类内部创建对象实例
        private static Singleton instance;
        static { //在静态代码块中，创建单例对象
            instance = new Singleton();
        }
        //3.提供一个公有的静态方法，返回实例对象
        public static Singleton getInstance() {
            return instance;
        }
    }
    ```

**优缺点说明：** 

1. 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。
2. 结论：这种单例模式可用，但是可能造成内存浪费。

### 懒汉式(线程不安全)

- 代码演示：

    ```Java
    //懒汉式(线程不安全) 在实际开发中，不要使用这种方法
    class Singleton {
        private static Singleton instance;
        private Singleton() {}
        //提供一个静态的公有方法，当使用到该方法时，才去创建instance
        //即懒汉式
        public static Singleton getInstance() {
            if (instance == null) {
                instance = new Singleton();
            }
            return instance;
        }
    }
    ```

**优缺点说明：**

1. 起到了Lazy Loading的效果，但是只能在单线程下使用。
2. 如果在多线程下，一个线程进入了if (singleton == null)判断语句块， 还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。
3. 结论:在实际开发中，**不要使用**这种方式。

### 懒汉式(线程安全，同步方法)

- 代码演示：

    ```java
    //懒汉式(线程安全,同步方法) 在实际开发中，不推荐使用这种方法，效率太低
    class Singleton {
        private static Singleton instance;
        private Singleton() {}
        //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题
        //即懒汉式
        public static synchronized Singleton getInstance() {
            if (instance == null) {
                instance = new Singleton();
            }
            return instance;
        }
    }
    ```

**优缺点说明：**

1. 解决了**线程安全**问题。
2. 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。**方法进行同步效率太低**。
3. 结论：在实际开发中，**不推荐**使用这种方式。

### 懒汉式(线程安全，同步代码块)

- 代码演示：

    ```Java
    //懒汉式(线程安全,同步代码块) 在实际开发中，不能使用这种方法
    class Singleton {
        private static Singleton instance;
        private Singleton() {}
        public static Singleton getInstance() {
            if (instance == null) {
                synchronized (Singleton.class) {
                    instance = new Singleton();
                }
            }
            return instance;
        }
    }
    ```

**达不到线程安全，不推荐使用！！！！！**

### 双重检查

- 代码演示：

    ```Java
    //双重检查 在实际开发中，推荐使用这种单例设计模式
    class Singleton {
        private static volatile Singleton instance;
        private Singleton() {}
        //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题
        //同时保证效率，推荐使用
        public static Singleton getInstance() {
            if (instance == null) {
                synchronized (Singleton.class) {
                    if (instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
    ```

**优缺点说明：**

1. Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。
2. 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步。
3. 线程安全；延迟加载；效率较高。
4. 结论：在实际开发中，**推荐使用这种单例设计模式**。

### 静态内部类

- 代码演示：

    ```Java
    //静态内部类，推荐使用
    class Singleton {
        //构造器私有化
        private Singleton() {}
        //写一个静态内部类，该类中有一个静态属性Singleton
        private static class SingletonInstance {
            private static final Singleton INSTANCE = new Singleton();
        }
        //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE
        public static Singleton getInstance() {
            return SingletonInstance.INSTANCE;
        }
    }
    ```

**优缺点说明**

1) 这种方式采用了**类装载的机制**来保证初始化实例时只有一个线程。
2) 静态内部类方式在Singleton类被装载时并**不会立即实例化**， 而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。
3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
4) 优点：避免了**线程不安全**，利用**静态内部类特点实现延迟加载，效率高**。
5) 结论：**推荐**使用。

### 枚举

- 代码演示：

    ```Java
    //使用枚举，推荐使用
    enum Singleton {
        INSTANCE; //属性
        public void sayOK() {
            System.out.println("ok~");
        }
    }
    ```

**优缺点说明**

1. 这借助JDK1.5中添加的枚举来实现单例模式。不仅**能避免多线程同步问题**，而且还能**防止反序列化重新创建新的对象**。
2. 这种方式是**Effective Java作者Josh Bloch提倡**的方式。
3. 结论：**推荐**使用。

### 单例模式在JDK应用的源码分析

**单例模式在JDK应用的源码分析**

- 我们JDK中，java.lang.Runtime就是经典的单例模式(饿汉式)。

- 代码分析+Debug源码+代码说明。

    ```Java
    public class Runtime {
        private static final Runtime currentRuntime = new Runtime();
        private static Runtime.Version version;
    
        public static Runtime getRuntime() {
            return currentRuntime;
        }
    
        private Runtime() {
        }
    }
    ```

### 单例模式注意事项和细节说明

**单例模式注意事项和细节说明**

1. 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需
    要频繁创建销毁的对象，使用单例模式可以提高系统性能。
2. 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使
    用new。
3. 单例模式**使用的场景**：需要**频繁的进行创建和销毁的对象**、创建对象时耗时过多或耗费资源过多(即：**重量级对象**)，但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象(比如**数据源、session工厂** 等)。





## 工厂模式(重点)

### 看一个具体的需求

看一个披萨的项目：要便于披萨种类的扩展，要便于维护

1. 披萨的种类很多(比如GreekPizz、CheesePizz等)。
2. 披萨的制作有prepare, bake, cut, box。
3. 完成披萨店订购功能。

### 简单工厂模式

**基本介绍**

1. 简单工厂模式是属于**创建型模式**，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中**最简单实用的模式**。
2. 简单工厂模式：定义了-一个创建对象的类，由这个类来**封装实例化对象的行为**(代码)。
3. 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。

**类图：**![image-20210828164820240](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210828164820240.png)

### 工厂方法模式

**基本介绍**

**工厂方法模式**：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将<span style="color:red">**对象的实例化推迟到子类**</span>。

**类图：**![image-20210828165508458](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210828165508458.png)

### 抽象工厂模式

**基本介绍**

1. 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。
2. 抽象工厂模式可以将**简单工厂模式和工厂方法模式**进行整合。
3. 从设计层面看，抽象工厂模式就是对 "简单工厂模式" 的改进(或者称为进一步的抽象)。
4. 将工厂抽象成**两层**，**AbsFactory(抽象工厂)** 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了**工厂簇**，更利于代码的维护和扩展。

**类图：**![image-20210828170031245](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210828170031245.png)

### 工厂模式在JDK-Calendar 应用的源码分析

**工厂模式在JDK-Calendar 应用的源码分析**

- JDK中的Calendar类中，就使用了简单工厂模式

- 源码分析+Debug源码+说明

    ```Java
    public static Calendar getInstance() {        
        Locale aLocale = Locale.getDefault(Category.FORMAT);        
        return createCalendar(defaultTimeZone(aLocale), aLocale);    
    
    }
    private static Calendar createCalendar(TimeZone zone, Locale aLocale) {		//根据TimeZone，Locale创建对应的实例 
        CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class,aLocale).getCalendarProvider();        
        if (provider != null) {            
            try {                
                return provider.getInstance(zone, aLocale);            
            } catch (IllegalArgumentException var7) {   
                
            }        
        }       
        Calendar cal = null;        
        if (aLocale.hasExtensions()) {            
            String caltype = aLocale.getUnicodeLocaleType("ca");            
            if (caltype != null) {                
                byte var6 = -1;                
                switch(caltype.hashCode()) {                
                    case -1581060683:                    
                        if (caltype.equals("buddhist")) {                        
                            var6 = 0;                    
                        }                    
                        break;                
                    case -752730191:                    
                        if (caltype.equals("japanese")) {                        
                            var6 = 1;                    
                        }                    
                        break;                
                    case 283776265:                    
                        if (caltype.equals("gregory")) {                        
                            var6 = 2;                    
                        }                
                }                
                switch(var6) {                
                    case 0:                    
                        cal = new BuddhistCalendar(zone, aLocale);                    
                        break;                
                    case 1:                    
                        cal = new JapaneseImperialCalendar(zone, aLocale);                    
                        break;               
                    case 2:                    
                        cal = new GregorianCalendar(zone, aLocale);                
                }            
            }        
        }        
        if (cal == null) {            
            if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {                
                cal = new BuddhistCalendar(zone, aLocale);            
            } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja" && aLocale.getCountry() == "JP") {               
                cal = new JapaneseImperialCalendar(zone, aLocale);            
            } else {                
                cal = new GregorianCalendar(zone, aLocale);            
            }        
        }       
        return (Calendar)cal;    
    }
    ```

### 工厂模式小结

1. 工厂模式的意义
    将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
2. 三种工厂模式(简单工厂模式、工厂方法模式、抽象工厂模式)
3. 设计模式的**依赖抽象**原则

➢ 创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用。
➢ 不要让类继承具体类，而是继承抽象类或者是实现interface(接口)。
➢ 不要覆盖基类中已经实现的方法。





## 原型设计模式（克隆）

### 克隆羊问题

现在有一只羊tom，姓名为: tom,年龄为: 1，颜色为：白色，请编写程序创建和tom
羊属性完全相同的10只羊。

<span style="color:red">**思路**</span>：Java 中 Object 类 是所有类的根类，Object 类提供 了一个 clone() 方法， 该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的Java 类必须要实现一个接口 Cloneable，该接口表示该类能够复制且具有复制的能力 => **原型模式**。

**应用案例：**

```Java
//克隆该实例，使用默认的clone方法来完成
@Override
protected Object clone() {    
    Sheep sheep = null;    
    try {        
        sheep = (Sheep)super.clone();    
    } catch (CloneNotSupportedException e) {        
        System.out.println(e.getMessage());        
        e.printStackTrace();    
    }    
    return sheep;
}
```

### 原型模式

**基本介绍**

1. 原型模式(Prototype模式)是指: 用**原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象**。
2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。
3. 工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 **对象.clone()**。
4. 形象的理解：孙大圣拔出猴毛， 变出其它孙大圣。

### 原型模式-原理结构图(UML类图)

**UML类图：**![image-20210830155840304](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210830155840304.png)

**原理结构图说明**

1. Prototype：原型类，声明一个克隆自己的接口
2. ConcretePrototype： 具体的原型类，实现一个克隆自己的操作
3. Client：让一个原型对象克隆自己，从而创建一个新的对象(属性一样)

### 原型模式在Spring框架中源码分析

原型模式在Spring框架中源码分析

1. Spring中原型bean的创建，就是原型模式的应用

2. 代码分析+Debug源码

    ![image-20210830160901556](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210830160901556.png) 

### 深入讨论-浅拷贝和深拷贝

**浅拷贝的介绍**

1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。
3. 前面我们克隆羊就是浅拷贝。
4. **浅拷贝**是使用**默认的clone()**方法来实现
    sheep = (Sheep) super.clone();

**深拷贝基本介绍**

1. 复制对 象的所有基本数据类型的成员变量值。

2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，**对象进行深拷贝要对整个对象(包括对象的)进行拷贝**。

3. 深拷贝实现方式1：**重写clone**方法来实现深拷贝。

4. 深拷贝实现方式2：通过**对象序列化**实现深拷贝(推荐)。

5. **应用案例：**

    ```Java
    //深拷贝 - 方式1 使用clone方法
    @Override
    protected Object clone() throws CloneNotSupportedException {    
        Object deep = null;    
        //这里完成对基本数据类型(属性)和String的克隆    
        deep = super.clone();    
        //对应用类型的属性，进行单独处理    
        DeepProtoType deepProtoType = (DeepProtoType) deep;    
        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();
        return deepProtoType;
    }
    
    //深拷贝 - 方式2 通过对象序列化实现(推荐)
    public Object deepClone() {    
        //创建对象    
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;
        try {        
            //序列化        
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this); 
            //当前这个对象以对象流的方式输出
            //反序列化        
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            DeepProtoType copyObj = (DeepProtoType) ois.readObject();
            return copyObj;
        } catch (Exception e){
            e.printStackTrace();
            return null;
        } finally {
            //关闭流
            try {
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            } catch (Exception e) {
                e.printStackTrace();
            }   
        }
    }
    ```

### 原型模式的注意事项和细节

1. 创建新的对象比较复杂时，可以利用原型模式**简化对象的创建过程，同时也能够提高效率**。
2. 不用重新初始化对象，而是**动态地获得对象运行时的状态**。
3. 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。
4. 在实现深克隆的时候可能需要比较复杂的代码。
5. **<font color=red>缺点</font>**：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，<font color=red>但对已有的类进行改造时，需要修改其源代码</font>，违背了 ocp 原则， 这点请注意。

## 建造者模式（build）

参考：https://blog.csdn.net/Liuxiangming1314/article/details/124339614：

### 盖房项目需求

1. 需要建房子：这一过程为打桩、砌墙、封顶。
2. 房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的。
3. 请编写程序，完成需求。

解决方案：将产品和产品建造过程解耦 => 建造者模式。

### 建造者模式

**基本介绍**

1. 建造者模式(Builder Pattern)又叫**生成器模式**，是一种对象**构建模式**。它可以将复杂对象的建造过程抽象出来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。
2. 建造者模式是步一步创建个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。

### 建造者模式的四个角色

1. **Product(产品角色)**：一个具体的产品对象。

2. **Builder(抽象建造者)**：创建一个Product对象的各个部件指定的**接口/抽象类**。

3. **ConcreteBuilder(具体建造者)**：实现接口，构建和装配各个部件。

4. **Director (指挥者)**：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。

5. 建造者模式原理类图：

    ![image-20210831113639960](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210831113639960.png)

### 建造者模式在JDK的应用和源码分析

**建造者模式在JDK的应用和源码分析**

1. java.lang.StringBuilder中的建造者模式
2. 代码说明+Debug源码![image-20210831114158810](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210831114158810.png)
3. 源码中建造者模式角色分析
    ➢ Appendable 接口定义了多个append方法(抽象方法)，即Appendable 为抽象建造者，定义了抽象方法。
    ➢ AbstractStringBuilder实现了Appendable 接口方法，这里的AbstractStringBuilder已经是建造者，只是不能实例化。
    ➢ StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由AbstractStringBuilder完成，而StringBuilder继承了AbstractStringBuilder。

### 建造者模式的注意事项和细节

1. 客户端(使用程序)不必知道产品内部组成的细节，**将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象**。
2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，**用户使用不同的具体建造者即可得到不同的产品对象**。
3. 可以**更加精细地控制产品的创建过程**。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
4. **增加新的具体建造者无须修改原有类库的代码**，指挥者类针对抽象建造者类编程，系统扩展方便，符合“**开闭原则**”。
5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<span style="color:red">**如果产品之间的差异性很大，则不适合使用建造者模式**</span>，因此其使用范围受到一定的限制。
6. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式。
7. **抽象工厂模式VS建造者模式**
    抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。

## 适配器模式（插座、兼容）

参考：https://blog.csdn.net/qq_38785977/article/details/125581096

### 旅游使用插座问题

**现实生活中的适配器例子**

泰国插座用的是两孔的(欧标)，可以买个多功能转换插头(适配器)，这样就可以使用了。

### 适配器模式

**基本介绍**

1. 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，**主的目的是兼容性**，让原本因接口不匹配不能一-起工作的两个类可以协同工作。其别名为包装器(Wrapper)。
2. 适配器模式属于结**构型模式**。
3. 主要分为三类：**类适配器模式、对象适配器模式、接口适配器模式**。

### 适配器模式工作原理

**工作原理**

1. 适配器模式：将一个类的接口转换成另一种接口，让**原本接口不兼容的类可以兼容**。

2. 从用户的角度看不到被适配者，是解耦的。

3. 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法。

4. 用户收到反馈结果，感觉只是和目标接口交互，如图

    ![image-20210901160556454](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210901160556454.png)

### 类适配器模式介绍

**基本介绍**：Adapter 类，通过继承src类，实现dst类接口，完成strc->dst的适配。

**类图**：

![image-20210901160804012](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210901160804012.png) 

**类适配器模式注意事项和细节**

1. Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定局限性。
2. src类的方法在Adapter中都会暴露出来，也增加了使用的成本。
3. 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。

### 对象适配器模式介绍

**基本介绍**

1. 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst类接口，完成src->dst的适配。
2. 根据“**合成复用原则**”，在系统中尽量**使用关联关系(聚合)来替代继承关系**。
3. **对象适配器模式是适配器模式常用的一种**。

**类图**：

![image-20210901161350608](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210901161350608.png)

**对象适配器模式注意事项和细节**

1. 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。
2. 使用成本更低，更灵活。

### 接口适配器模式介绍

**基本介绍**

1. 一些书籍称为：适配器模式(Default Adapter Pattern)或**缺省适配器模式**。
2. **核心思想**：当**不需要全部实现接口提供的方法时**，可先**设计一个抽象类实现接口**，并为该接口中每个方法提供一个默认实现(空方法)，那么**该抽象类的子类可有选择地覆盖父类的某些方法**来实现需求。
3. 适用于一个接口不想使用其所有的方法的情况。

**类图**：![image-20210901162545256](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210901162545256.png)

### 适配器模式在SpringMVC框架应用的源码剖析

**适配器模式在SpringMVC框架应用的源码剖析**

1. SpringMvc中 的**HandlerAdapter**，就使用了适配器模式。
2. SpringMVC处理请求的流程回顾
3. 使用HandlerAdapter的原因分析：
    可以看到处理器的类型不同，有**多重实现方式，那么调用方式就不是确定的**，如果需要直接调用Controller方法，需要调用的时候就得不断是使用if-else来进行判断是哪一种子类然后执行。那么如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则。
4. 代码分析+Debug源码![image-20210901163229946](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210901163229946.png)

**说明**：

- Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类。
- 适配器代替Controller执行相应的方法。
- 扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。
- 这就是设计模式的力量。![image-20210901163506928](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210901163506928.png)

### 适配器模式的注意事项和细节

1. 三种命名方式，是根据src是以怎样的形式给到Adapter(在Adapter里的形式)来命名的。
2. 类适配器：以类给到，在Adapter里， 就是将src当做类，继承。
    对象适配器：以对象给到，在Adapter里， 将src作为一个对象，持有。
    接口适配器：以接口给到，在Adapter里， 将src作为一个接口，实现。
3. Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。
4. 实际开发中，实现起来不拘泥于我们讲解的三种经典形式。

## 桥接模式（层次包含）

参考：https://blog.csdn.net/weixin_43956958/article/details/125335780

![image-20221009150309716](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20221009150309716.png)

使用**桥接模式解决手机操作问题类图**：

![image-20210902115111125](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210902115111125.png)

### 桥接模式

**基本介绍**

1. 桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。

2. 是一种结构型设计模式。

3. Bridge模式**基于类的最小设计原则**，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。

4. 桥接模式原理类图：

    ![image-20210902114232139](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210902114232139.png)

**原理类图说明**:

1. Client类：桥接模式的调用者
2. 抽象类(Abstraction)：维护了Implementor / 即它的实现类ConcreteImplementorA...二者是聚合关系。Abstraction充当桥接类。
3. RefinedAbstraction：是Abstraction抽象类的子类。
4. Implementor：行为实现类的接口。
5. ConcretelmplementorA/B：行为的具体实现类。
6. 从UML图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系。

### 桥接模式在JDBC的源码剖析

**桥接模式在JDBC的源码剖析**

1. Jdbc 的 Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的Driver，Oracle的Driver，这些就可以当做实现接口类。
2. 代码分析+Debug源码。![image-20210902115430707](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210902115430707.png)
3. 对Jdbc源码分析的类图![image-20210902115650039](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210902115650039.png)

### 桥接模式的注意事项和细节

1. 实现了**抽象和实现部分的分离**，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有**助于系统进行分层设计**，从而产生更好的结构化系统。
2. 对于系统的高层部分，**只需要知道抽象部分和实现部分的接口就可以了**，其它的部分由具体业务来完成。
3. 桥接模式**替代多层继承方案，可以减少子类的个数**，降低系统的管理和维护成本。
4. 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。
5. 桥接模式**要求正确识别出系统中两个独立变化的维度**，因此其使用范围有一定的局限性，即需要有这样的应用场景。

### 桥接模式其它应用场景

对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

**常见的应用场景**：

- **JDBC驱动程序**
- **银行转账系统**
    转账分类：网上转账，柜台转账，AMT转账
    转账用户类型：普通用户，银卡用户，金卡用户...
- **消息管理**
    消息类型：即时消息，延时消息
    消息分类：手机短信，邮件消息，QQ消息...

## 装饰者模式(重点、包装)

参考：https://zhuanlan.zhihu.com/p/421998141


### 星巴克咖啡订单项目

**星巴克咖啡订单项目(咖啡馆)** ：

1. 咖啡种类/单品咖啡：Espresso(意 大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)
2. 调料：Milk、Soy(豆 浆)、Chocolate
3. 要求在扩展**新的咖啡种类**时，具有良好的扩展性、改动方便、维护方便
4. 使用OO的来计算不同种类咖啡的**费用**：客户可以点**单品咖啡**，也可以**单品咖啡+调料组合**。

### 装饰者模式定义

**装饰者模式定义**

1. 装饰者模式：**动态的**将新功能**附加到对象上**。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)。
2. 这里提到的**动态的将新功能附加到对象**和**ocp原则**，在后面的应用实例上会以代码的形式体现。
3. 装饰者模式解决星巴克订单项目问题类图：![image-20210902174613610](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210902174613610.png)

### 装饰者模式在JDK应用的源码分析

**装饰者模式在JDK应用的源码分析**

1. Java的IO结构，FilterInputStream就是一个装饰者。![image-20210902175051964](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210902175051964.png)

2. 源码说明：

    ```java
    DataInputStream dis = new DataInputStream(new FileInputStream("C:\\"));
    dis.read();
    dis.close();
    ```





## 组合模式（将对象组合成树形结构）

参考：

### 学校院系展示需求

**看一个学校院系展示需求**

编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。

**传统解决方式**

1. 将**学院看做是学校的子类，系是学院的子类**，这样实际上是站在组织大小来进行分层次的。
2. 实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现的**管理的操作**，比如对学院、系的添加，删除，遍历等。
3. 解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作 => **组合模式**。

### 组合模式

**基本介绍**

1. 组合模式(Composite Pattern)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“**整体-部分**”的层次关系。

2. 组合模式**依据树形结构来组合对象**，用来表示部分以及整体层次。

3. 这种类型的设计模式属于结构型模式。

4. 组合模式使得**用户对单个对象和组合对象的访问具有一致性**，即：组合能让客户以一致的方式处理个别对象以及组合对象。

5. 类图

    ![image-20210903192845307](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210903192845307.png)

### 组合模式在JDK集合的源码分析

**组合模式在JDK集合的源码分析**

1. Java的集合类-HashMap就使用了组合模式
2. 代码分析+Debug源码![image-20210903193159616](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210903193159616.png)
3. 类图![image-20210903193134140](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210903193134140.png)

### 组合模式的注意事项和细节

1. 简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。
2. 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。
3. 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构。
4. **需要遍历组织机构，或者处理的对象具有树形结构时**，非常适合**使用组合模式**。
5. 要求较高的抽象性，**如果节点和叶子有很多差异性的话**，比如很多方法和属性都不一样，**不适合使用组合模式**。





##  外观模式（client）

### 影院管理项目

**组建一个家庭影院**：

DVD播放器、投影仪、自动屏幕、环绕立体声、爆米花机,要求完成使用家庭影院的
功能，其过程为：
●直按用遥控器：统筹各设备开关
●开爆米花机
●放下屏幕
●开投影仪
●开音响
●开DVD，选DVD
●去拿爆米花
●调暗灯光
●播放
●观影结束后，关闭各种设备

**解决思路**：

1. **定义一个高层接口**，给**子系统中的一组接口提供一个一致的界面**(比如在高层接口提供四个方法ready，play，pause，end)，用来访间子系统中的一群接口。
2. 也就是说就是通过定义一个一致的接口(界面类)，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节 => 外观模式。

### 外观模式

**基本介绍**

1. 外观模式(Facade)，也叫 “**过程模式**” 外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
2. 外观模式通过定义一个一致的接口，用以**屏蔽内部子系统的细节**，使得**调用端只需跟这个接口发生调用**，而无需关心这个子系统的内部细节。

### 外观模式在MyBatis框架应用的源码分析

**外观模式在MyBatis框架应用的源码分析**

1. MyBatis中的Configuration去创建MetaObject对象使用到外观模式。
2. 代码分析+Debug源码+示意图。![image-20210904172005596](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210904172005596.png)

### 外观模式的注意事项和细节

1. **外观模式对外屏蔽了子系统的细节**，因此外观模式降低了客户端对子系统使用的复杂性。
2. 外观模式对**客户端与子系统的耦合关系-解耦**，让子系统内部的模块更易维护和扩展。
3. 通过合理的使用外观模式，可以帮我们更好的**划分访问的层次**。
4. 当系统需要进行分层设计时，可以考虑使用Facade模式。
5. 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性。
6. 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。





## 享元模式（抽离所有类中的特定内部状态为常量）

### 展示网站项目需求

小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：

1. 有客户要求以新闻的形式发布。
2. 有客户人要求以博客的形式发布。
3. 有客户希望以微信公众号的形式发布。

### 传统方案解决网站展现项目-问题分析

**传统方案解决网站展现项目-问题分析**

1. 需要的网站结构**相似度很高**，而且都不是高访问量网站，如果分成多个虚拟空间来处理， 相当于一个相同网站的实例对象很多，造成服务器的资源浪费。
2. 解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源。
3. 对于代码来说，由于是一份实例，维护和扩展都更加容易。
4. 上面的解决思路就可以使用**享元模式**来解决。

### 享元模式

**基本介绍**

1. 享元模式(Flyweight Pattern)也叫**蝇量模式**：用共享技术有效地支持大量细粒度的对象。
2. 常用于系统底层开发，解决系统的性能问题。像**数据库连接池**，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。
3. 享元模式能够解决**重复对象的内存浪费的问题**，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。
4. 享元模式**经典的应用场景就是池技术了**，**String常量池、数据库连接池、缓冲池**等等都是享元模式的应用，享元模式是池技术的重要实现方式。
5. 类图：![image-20210905210950101](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210905210950101.png)

**对原理图的说明-即(模式的角色及职责)**

1. FlyWeight 是抽象的享元角色，他是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。
2. ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务。
3. UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂。
4. FlyWeightFactory 享元工厂 类，用于构建个池容器(集合)， 同时提供从池中获取对象方法。

### 内部状态和外部状态

1. 享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：**内部状态和外部状态**。
2. **内部状态**指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变。
3. **外部状态**指对象得以依赖的一个标记，是**随环境改变而改变的、不可共享的状态**。
4. 举个例子：围棋理论上有361个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题。

### 享元模式在JDK-Integer的应用源码分析

**享元模式在JDK-Integer的应用源码分析**

1. Integer中的享元模式

2. 代码分析+Debug源码+说明

    ```java
    //小结:
    //1.在valueOf 方法中，先判断值是否在IntegerCache中，如果不在，就创建新的Integer(new),否则，就直接从缓存池返回
    //2.valueOf 方法，就使用到享元模式
    //3.如果使用valueOf方法得到一个Integer实例，范围在-128 - 127 ，执行速度比new快
    
    Integer x = Integer.valueOf(127); //得到x实例，类型Integer
    Integer y = new Integer(127); //得到y实例,类型Integer
    Integer z = Integer.valueOf(127);//..
    Integer w = new Integer(127);
    System. out. println(x. equals(y)); //大小，true
    System.out.println(x == y ); // false
    System.out. println(x == z); // true
    System.out.println(w == x ); // false
    System.out.println(w == y ); // false//小结:
    //1.在valueOf 方法中，先判断值是否在IntegerCache中，如果不在，就创建新的Integer(new),否则，就直接从缓存池返回
    //2.valueOf 方法，就使用到享元模式
    //3.如果使用valueOf方法得到一个Integer实例，范围在-128 - 127 ，执行速度比new快
    
    Integer x = Integer.valueOf(127); //得到x实例，类型Integer
    Integer y = new Integer(127); //得到y实例,类型Integer
    Integer z = Integer.valueOf(127);//..
    Integer w = new Integer(127);
    System. out. println(x. equals(y)); //大小，true
    System.out.println(x == y ); // false
    System.out. println(x == z); // true
    System.out.println(w == x ); // false
    System.out.println(w == y ); // false
    ```

### 享元模式的注意事项和细节

1. 在享元模式这样理解，“享” 就**表示共享**，“元” **表示对象**。
2. 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式。
3. 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储。
4. 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率。
5. 享元模式**提高了系统的复杂度**。需要**分离出内部状态**和**外部状态**，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方。
6. 使用享元模式时，**注意划分内部状态和外部状态**，并且需要有一个**工厂类**加以控制。
7. 享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池。




## 代理模式(重点，额外增强功能，进行扩展)

### 代理模式

**基本介绍**

1. 代理模式：为一个对象**提供一个替身**，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。
2. 被代理的对象可以是**远程对象**、**创建开销大的对象或需要安全控制的对象**。
3. 代理模式有不同的形式，主要有三种<span style="color:red">**静态代理、动态代理(JDK代理、接口代理)和Cglib代理(可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴)**</span>。
4. 代理模式示意图![image-20210906213051484](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210906213051484.png)

### 静态代理

**静态代码模式的基本介绍**

静态代理在使用时，需要定义接口或者父类，被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类。

**具体要求**

1. 定义一个接口：ITeacherDao。
2. 目标对象TeacherDAO实现接口ITeacherDAO。
3. 使用静态代理方式，就需要在代理对象TeacherDAOProxy中也实现TeacherDAO。
4. 调用的时候通过调用代理对象的方法来调用目标对象。
5. 特别提醒：代理对象与目标对象要实现相同的接口然后通过调用相同的方法来调用目标对象的方法。
6. 类图![image-20210906213531102](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210906213531102.png)

**静态代理优缺点**

1. 优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展。
2. 缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类。
3. 一旦接口增加方法，目标对象与代理对象都要维护。

### 动态代理

**动态代理模式的基本介绍**

1. 代理对象，**不需要实现接口**，但是**目标对象要实现接口**，否则不能用动态代理。
2. 代理对象的生成，是利用JDK的API，动态的在内存中构建代理对象。
3. 动态代理也叫做：**JDK代理、接口代理**。

**JDK中生成代理对象的API**

1. 代理类所在包：java.lang.reflect.Proxy

2. JDK实现代理只需要使用newProxyInstance方法，但是该方法需要接收三个参数，完整的写法是：

    ```Java
    static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
    ```

3. 类图![image-20210906214255353](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210906214255353.png)

### Cglib代理

**Cglib代理模式的基本介绍**

1. 静态代理和JDK代理模式都要求目标对象是实现一个接口，**但是有时候目标对象只是一个单独的对象，并没有实现任何的接口**，这个时候可使用目标对象子类来实现代理--这就是**Cglib代理**。
2. Cglib代理也叫作**子类代理**，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也**将Cglib代理归属到动态代理**。
3. Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口。它广泛的被许多AOP的框架使用，例如Spring AOP，实现方法拦截。
4. 在AOP编程中如何选择代理模式：
    1.目标对象**需要实现接口**，用JDK代理。
    2.目标对象**不需要实现接口**，用Cglib代理。
5. Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类。
6. 类图![image-20210906215423188](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210906215423188.png)

**需要引入的jar包**

```java
asm.jar
asm-commons.jar
asm-tree.jar
cglib-2.2jar
```

注：在内存中动态构建子类，注意**代理的类不能为final**，否则报错

```java
java.lang.IllegalArgumentException;
```

目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法。

### 代理模式(Proxy)的变体

**几种常见的代理模式介绍--几种变体**

1. **防火墙代理**
    内网通过代理穿透防火墙，实现对公网的访问。
2. **缓存代理**
    比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok，如果取不到资源，再到公网或者数据库取，然后缓存。
3. **远程代理**
    **远程对象的本地代表**，通过它可以**把远程对象当本地对象**来调用。远程代理通过网络和真正的远程对象沟通信息。
4. **同步代理**：主要使用在多线程编程中，完成多线程间同步工作。




## 模板方法模式

### 豆浆制作问题

1. **编写制作豆浆的程序，说明如下：**
2. 制作豆浆的流程选材-->添加配料-->浸泡-->放到豆浆机打碎。
3. 通过添加不同的配料，可以制作出不同口味的豆浆。
4. 选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的，使用**模板方法模式**完成。
5. 类图![image-20210907165505499](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210907165505499.png)

### 模板方法模式

**基本介绍**

1. 模板方法模式(Template Method Pattern)，又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
2. 简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变-一个算法的结构，就可以重定义该算法的某些特定步骤。
3. 这种类型的设计模式属于**行为型模式**。
4. 类图![image-20210907165308908](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210907165308908.png)

**对原理类图的说明-即(模板方法模式的角色及职责)**

1. AbstractClass 抽象类，类中实现 了模板方法(template)，定义了算法的骨架，具体子类需要去实现其它的抽象方法operationr2，3，4。
2. ConcreteClass 实现抽象方法operationr2，3，4，以完成算法中特点子类的步骤。

### 模板方法模式的钩子方法

**模板方法模式的钩子方法**

1. 在模板方法模式的**父类中**，我们可以定义一个方法，它默认**不做任何事**，子类可以视情况要不要覆盖它，该方法称为“钩子”。
2. 还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，就使用钩子方法对前面的模板方法进行改造。

### 模板方法模式在Spring框架应用的源码分析

**模板方法模式在Spring框架应用的源码分析**

1. Spring IOC容器初始化时运用到的模板方法模式
2. 代码分析+角色分析+说明类图![image-20210907170619628](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210907170619628.png)

### 模板方法模式的注意事项和细节

1. 基本思想是：**算法只存在于一个地方，也就是在父类中，容易修改**。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改。
2. **实现了最大化代码复用**。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。
3. **既统一了算法，也提供了很大的灵活性**。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。
4. 该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。
5. 一般模板方法都加上**final关键字**，防止子类重写模板方法。
6. 模板方法模式使用场景：**当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同**，但其**个别步骤在实现时可能不同**，通常考虑用模板方法模式来处理。




## 命令模式

### 智能生活项目需求

**看一个具体的需求**

1. 我们买了一 套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装app就可以控制对这些家电工作。
2. 这些智能家电来自不同的厂 家，我们不想针对每一种家电都安装一个App，分别控制，我们希望只要一个app就可以控制全部智能家电。
3. 要实现一个app控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给app调用，这时就可以考虑使用命令模式。
4. 命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来。
5. 在我们的例子中，动作的请求者是手机app，动作的执行者是每个厂商的一个家电产品。
6. 类图![image-20210908205849913](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210908205849913.png)

### 命令模式

**基本介绍**

1. 命令模式(Command Pattem)：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计。
2. 命名模式使得**请求发送者与请求接收者消除彼此之间的耦合**，让对象之间的调用关系更加灵活，实现解耦。
3. 在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。
4. 通俗易懂的理解，将军发布命令，士兵去执行。其中有几个角色：将军(命令发布者)、士兵(命令的具体执行者)、命令(连接将军和士兵)。Invoker是调用者(将军)，Receiver是被调用者(士兵)，MyCommand是命令，实现了Command接口，持有接收对象。
5. 类图![image-20210908205707951](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210908205707951.png)

**对原理类图的说明-即(命名模式的角色及职责)**

1. Invoker：是调用者角色。
2. Command：是命令角色，需要执行的所有命令都在这里，可以是接口或抽象类。
3. Receiver：接受者角色，知道如何实施和执行一个请求相关的操作。
4. ConcreteCommand：将一个接受者对象与一个动作绑定，调用接受者相应的操作，实现execute()。

### 命令模式在Spring框架JdbcTemplate应用的源码分析

**命令模式在Spring框架JdbcTemplate应用的源码分析**

1. Spring框架的JdbcTemplate就使用到了命令模式
2. 代码分析![image-20210908210255300](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210908210255300.png)
3. 模式角色分析说明
    - **StatementCallback**接口，类似命令接口(Command)。
    - **class QueryStatementCallback implements StatementCallback<T>, SqlProvider**，匿名内部类，实现了 命令接口，同时也充当命令接收者。
    - 命令调用者是**JdbcTemplate**，其中**execute(StatementCallback<T> action)**方法中，调用**action.doInStatement**方法。不同的实现**StatementCallback**接口的对象，对应不同的**doInStatemnt**实现逻辑。

### 命令模式的注意事项和细节

1. 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收者工作，而**不必知道具体的接收者对象是谁**、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。
2. 容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令。
3. 容易**实现对请求的撤销和重做**。
4. **命令模式不足**：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意。
5. **空命令也是一种设计模式**，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。
6. 命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟CMD(DOS命令)订单的撤销/恢复、触发-反馈机制。




## 访问者模式

### 访问者模式

**基本介绍**

1. 访问者模式(Visitor Pattern)，封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
2. 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题。
3. 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口。
4. 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作"污染"这些对象的类，可以选用访问者模式解决。
5. 类图![image-20210909222127439](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210909222127439.png)

**对原理类图的说明-即(访问者模式的角色及职责)**

1. Visitor：是抽象访问者，为该对象结构中的ConcreteElement的每一 个类声明y一个visit操作。
2. ConcreteVisitor：是一个具体的访问值实现每个有Visitor声明的操作，是每个操作实现的部分。
3. ObjectStructure：能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问元素。
4. Element：定义一个accept方法，换收一个访问者对象。
5. ConcreteElement：为具体元素，实现了accept方法。

**双分派**

所谓双分派是指不管类怎么变化，我们都能找到期望的方法运行。双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型。

### 访问者模式的注意事项和细节

**➢优点**

1. 访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高。
2. 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统。

**➢缺点**

1. 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样**造成了具体元素变更比较困难**。
2. 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素。
3. 因此，如果一个系统**有比较稳定的数据结构**，**又有经常变化的功能需求**，那么访问者模式就是比较合适的。




## 迭代器模式

### 看一个具体需求

编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。

### 迭代器模式

**基本介绍**

1. 迭代器模式(Iterator Pattern)是**常用的设计模式**，属于行为型模式。
2. 如果我们的**集合元素是用不同的方式实现**的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。
3. 迭代器模式，**提供一种遍历集合元素的统一接口**，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。
4. 类图![image-20210910220638052](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210910220638052.png)

**对原理类图的说明-即(迭代器模式的角色及职责)**

1. Iterator：送代器接口，是系统提供，包含hasNext，next，remove。
2. ConcreteIterator：具体的送代器类，管理迭代。
3. Aggregate：一个统一的聚合接口，将客户端和具体聚合解耦。
4. ConcreteAggregate：具体的聚合持有对像集合，并提供一个方法，返回一个迭代器，该迭代器可以正确遍历集合。
5. Client：客户端，通过Iterator和Aggregate依赖子类。

### 迭代器模式在JDK-ArrayList集合应用的源码分析

**迭代器模式在JDK-ArrayList集合应用的源码分析**

1. JDK的ArrayList集合中就使用了迭代器模式
2. 代码分析+类图+说明![image-20210910221628425](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210910221628425.png)
3. 类图![image-20210910221708327](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210910221708327.png)

**角色分析说明**

1. 内部类Itr充当具体实现迭代器Iterator的类，作为ArrayList内部类。
2. List就是充当了聚合接口，含有一个iterator()方法，返回一个迭代器对象。
3. ArrayList是实现聚合接口List的子类，实现了iterator()。
4. Iterator接口系统提供。
5. 迭代器模式解决了不同集合(ArrayList，LinkedList) 统一遍历问题。

### 迭代器模式的注意事项和细节

**➢优点**

1. 提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。
2. 隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。
3. 提供了一种设计思想，就是一个类应该只有一个引起变化的原因(叫做**单一责任原则**)。在聚合类中，我们把迭代器分开，就是要把**管理对象集合和遍历对象集合的责任分开**，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。
4. 当要展示一组相似对象，或者遍历一组相同对象时使用，适合使用迭代器模式。

**➢缺点**

- 每个聚合对象都要一个迭代器， 会生成多个迭代器不好管理类。




## 观察者模式(重点)

### 天气预报项目需求

天气预报项目需求，具体要求如下：

1. 气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。
2. 需要设计**开放型API**，便于其他第三方也能接入气象站获取数据。
3. 提供温度、气压和湿度的接口。
4. 测量数据更新时，要能实时的通知给第三方。
5. 类图![image-20210911230625907](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210911230625907.png)

### 观察者模式(Observer)原理

**观察者模式原理**

➢观察者模式类似订牛奶业务

1. 奶站/气象局：Subject。
2. 用户/第三方网站：Observer。![image-20210911230117448](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210911230117448.png)

➢Subject：登记注册、 移除和通知

1. registerObserver 注册。
2. removeObserver 移除。
3. notilyObservers() 通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实施推送，看具体需求定。

➢Observer：接收输入![image-20210911230422645](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210911230422645.png)

➢观察者模式：对象之间**多对一依赖**的一种设计方案，被依赖的对象为Subject，依赖的对象为Observer，Subject通知Observer变化，比如这里的奶站是Subject，是1的一方。用户时Observer，是多的一方。

### 观察者模式的好处

1. 观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除和通知。
2. 这样，我们增加观察者(这里可以理解成一个新的公告板)，就不需要去修改核心类WeatherData不会修改代码，遵守了ocp原则。

### 观察者模式在Jdk应用的源码分析

**观察者模式在Jdk应用的源码分析**

1. Jdk的Observable类就使用了观察者模式

2. 代码分析+模式角色分析![image-20210911231034972](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210911231034972.png)

3. 模式角色分析

    Observable 的作用和地位等价于我们前面讲过Subject。

    Observable 是类，不是接口，类中已经实现了核心的方法，即管理Observer的方法add.. delete .. notify...

    Observer的作用和地位等价于我们前面讲过的Observer，有update。

    Observable和Observer的使用方法和前面讲过的一样，只是Observable是
    类，通过继承来实现观察者模式。




## 中介者模式

### 智能家庭管理问题

**智能家庭项目**：

1. 智能家庭包括各种设备，闹钟、咖啡机、电视机、窗帘等。
2. 主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作，比如流程为：闹铃响起->咖啡机开始做咖啡-> 窗帘自动落下->电视机开始播放。
3. 类图![image-20210912173528428](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210912173528428.png)

### 中介者模式

**基本介绍**

1. 中介者模式(Mediator Pattern)，用一个**中介对象来封装一系列的对象交互**。中介者使各个对象不需要显式地相互引用，从而**使其耦合松散**，而且可以独立地改变它们之间的交互。
2. 中介者模式属于行为型模式，使代码易于维护。
3. 比如MVC模式，C (Controller控制器) 是M (Model模型) 和V (View视图)的中介者，在前后端交互时起到了中间人的作用。
4. 类图![image-20210912173152237](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210912173152237.png)

### 中介者模式的注意事项和细节

1. 多个类相互耦合，会形成网状结构，使用中介者模式将网状结构分离为星型结构，进行解耦。
2. 减少类间依赖，降低了耦合，符合迪米特原则。
3. **中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响**。
4. 如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意。




## 备忘录模式

### 游戏角色状态恢复问题

**游戏角色状态恢复问题**

游戏角色有攻击力和防御力，在大战Boss前保存自身的状态(攻击力和防御力)，当大战Boss后攻击力和防御力下降，从备忘录对象恢复到大战前的状态。

类图![image-20210913225858684](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210913225858684.png)

### 备忘录模式

**基本介绍**

1. 备忘录模式(Memento Pattern)在**不破坏封装性的前提下**，**捕获一个对象的内部状态**，并在该对象之外保存这个状态。这样以后就**可将该对象恢复到原先保存的状态**。
2. 可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作。
3. 备忘录模式属于行为型模式。
4. 类图![image-20210913225037437](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210913225037437.png)

**对原理类图的说明-即(备忘录模式的角色及职责)**

1. originator：对象(需要保存状态的对象)。
2. Memento：备忘录对象，负责保存好记录，即Originator内部状态。
3. Caretaker：守护者对象,负责保存多个备忘录对象，使用集合管理， 提高效率。
4. 说明：如果希望保存多个originator对象的不同时间的状态，也可以，只需要要HashMap<String, 集合>。

### 备忘录模式的注意事项和细节

1. 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。
2. 实现了信息的封装，使得用户不需要关心状态的保存细节。
3. 如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存，这个需要注意。
4. 适用的应用场景：1、后悔药。2、打游戏时的存档。3、Windows里的ctri +z。4、IE中的后退。4、数据库的事务管理。
5. 为了节约内存，备忘录模式可以和原型模式配合使用。




## 解释器模式

### 四则运算问题

**通过解释器模式来实现四则运算，如计算a+b-c的值，具体要求**

1. 先输入表达式的形式，比如a+b+c-d+e，要求表达式的字母不能重复
2. 在分别输入a,b,c,d,e的值
3. 最后求出结果
4. 类图![image-20210914162958275](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914162958275.png)

**解决方案**：可以考虑使用解释器模式，即：表达式- > 解释器(可以有多种) -> 结果

### 解释器模式

**基本介绍**

1. 在编译原理中，一个算术表达式通过**词法分析器**形成词法单元，而后这些词法单元再通过**语法分析器**构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器。

2. 解释器模式(Interpreter Pattern)：**是指给定一个语言(表达式)，定义它的文法的一种表示**，并定义**一个解释器**，使用该**解释器来解释语言中的句子(表达式)**。

3. 应用场景

    - 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。

    - 一些重复出现的问题可以用一种简单的语言来表达。

    - 一个简单语法需要解释的场景。

4. 这样的例子还有，比如编译器、运算表达式计算、正则表达式、机器人等。

5. 类图![image-20210914162239032](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914162239032.png)

**对原理类图的说明-即(解释器模式的角色及职责)**

1. Context：是环境角色，含有解释器之外的全局信息。
2. AbstractExpression：抽象表达式，声明一个抽象的解释操作，这个方法为抽象语法树中所有的节点所共享。
3. TerminalExpression：为终结符表达式，实现与文法中的终结符相关的解释操作。
4. NonTermialExpression：为非络结符表达式，为文法中的非络结符实现解释操作。
5. 说明：输入Context 和 TerminalExpression信息通过Client输入即可。

### 解释器模式在Spring框架应用的源码剖析

**解释器模式在Spring框架应用的源码剖析**

1. Spring框架中SpelExpressionParser就使用到解释器模式
2. 代码分析+Debug源码![image-20210914163418817](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914163418817.png)
3. 说明
    - Expression接口表达式接口。
    - 下面有不同的实现类，比如SpelExpression，或者CompositeStringExpression。
    - 使用时候，根据你创建的不同的Parser对象，返回不同的Expression对象。
    - 使用得当Expression对象，调用getValue解释执行表达式，最后得到结果。

### 解释器模式的注意事项和细节

1. 当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展性。
2. 应用场景：编译器、运算表达式计算、正则表达式、机器人等。
3. 使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低。




## 状态模式

### APP抽奖活动问题

**请编写程序完成APP抽奖活动具体要求如下**：

1. 假如每参加一次这个活动要扣除用户50积分，中奖概率是10%。
2. 奖品数量固定，抽完就不能抽奖。
3. 活动有四个状态：可以抽奖、不能抽奖、发放奖品和奖品领完。
4. 状态转换图![image-20210914190806016](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914190806016.png)
5. 类图![image-20210914172635158](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914172635158.png)

### 状态模式

**基本介绍**

1. 状态模式(State Pattern)：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之，间可以相互转换。
2. 当一个**对象的内在状态改变时，允许改变其行为**，这个对象看起来像是改变了其类。
3. 类图![image-20210914171603822](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914171603822.png)

**对原理类图的说明-即(状态模式的角色及职责)**

1. Context：为环境角色，用于维护State实例，这个实例定义当前状态。
2. State：是抽象状态角色，定义一个接口封装与Context的一个特定接口相关行为。
3. ConcreteState：具体的状态角色，每个子类实现一个与Context的一个状态相关行为。

### 状态模式在实际项目-借贷平台源码剖析

**状态模式在实际项目-借贷平台源码剖析**

1. 借贷平台的订单，有审核-发布-抢单等等步骤，随着操作的不同，会改变订单的状态，项目中的这个模块实现就会使用到状态模式。

2. 通常通过if/else判断订单的状态，从而实现不同的逻辑，伪代码如下

    ```Java
    if (审核) {
    	//审核逻辑
    } else if (发布) {
    	//发布逻辑
    } else if (接单) {
    	//接单逻辑
    }
    /*
    问题分析:
    这类代码难以应对变化，在添加一种状态时，我们需要手动添加if/else，在添加一种功能时，要对所有的状态进行判断。因此代码会变得越来越臃肿，并且一旦没有处理某个状态，便会发生极其严重的BUG,难以维护。
    */
    ```

3. 使用状态模式完成借贷平台项目的审核模块[状态图+类图]
    ![image-20210914184321016](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914184321016.png)
    ![image-20210914184506390](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914184506390.png)
    ![image-20210914185337089](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914185337089.png)

### 状态模式的注意事项和细节

1. 代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中。
2. 方便维护。将容易产生间题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多if-else语句，而且容易出错。
3. 符合“开闭原则”。容易增删状态。
4. 会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度。
5. 应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式。




## 策略模式

### 鸭子问题

**编写鸭子项目，具体要求如下**：

1. 有各种鸭子(比如野鸭、北京鸭、水鸭等，鸭子有各种行为，比如叫、飞行等)。
2. 显示鸭子的信息。
3. 类图![image-20210914235249116](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914235249116.png)

### 策略模式

**基本介绍**

1. 策略模式(Strategy Pattern)中，定义**算法族(策略组)**，分别封装起来，让他们之间可以互相替换，此模式让**算法的变化独立于使用算法的客户**。
2. 这算法体现了几个设计原则，第一、 把变化的代码从不变的代码中分离出来；第二、针对接口编程而不是具体类(定义了策略接口)；第三、多用组合/聚合，少用继承(客户通过组合方式使用策略)。
3. 类图![image-20210914225954642](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914225954642.png)

说明：从上图可以看到，客户context有成员变量strategy或者其他的策略接口
，至于需要使用到哪个策略，我们可以在构造器中指定。 

### 策略模式在JDK-Arrays应用的源码分析

**策略模式在JDK-Arrays应用的源码分析**

1. JDK的Arrays的Comparator就使用了策略模式

2. 代码分析+Debug源码+模式角色分析![image-20210914235545447](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210914235545447.png)

    ```java
    //方式1
    //数组
    Integer[] data = {9, 1, 2, 8, 4, 3};
    //实现升序排序，返回-1放左边，1放右边，0保持不变
    //说明
    // 1.实现了Comparator接口(策略接口)，匿名类对象new Comparator<Integer>(){..}
    // 2.对象new Comparator<Integer>(){..} 就是实现了策略接口的对象
    // 3.public int compare(Integer o1, Integer o2){}指定具体的处理方式
    Comparator<Integer> comparator = new Comparator<Integer>() {
        public int compare(Integer o1, Integer o2) {
            if (o1 > o2) {
                return 1;
            } else {
                return -1;
            }
        }
    };
    /*
    说明
    public static <T> void sort(T[] a, Comparator<? super T> c) {
    	if (c == null) {
    		sort(a); //默认方法
    	} else {
    		if (LegacyMergeSort.userRequested)
    			legacyMergeSort(a, c); //使用策略对象c
    		else
    			//使用策略对象c
    			TimSort.sort(a, 0, a.length, c, null, 0, 0);
    	}
    }
    */
    Arrays.sort(data, comparator);
    System.out.println(Arrays.toString(data)); //升序排列
    
    //方式2 - lambda表达式实现 策略模式
    Integer[] data2 = {9, 1, 2, 8, 4, 3};
    Arrays.sort(data2, (var1, var2) -> {
    	if (var1.compareTo(var2) > 0) {
    		return 1;
    	} else {
    		return -1;
    	}
    });
    System.out.println("data2=" + Arrays.toString(data2));
    ```

### 策略模式的注意事项和细节

1. 策略模式的关键是：分析项目中变化部分与不变部分。
2. 策略模式的核心思想是：多用**组合/聚合**少用继承；用行为类组合，而不是行为的继承。更有弹性。
3. 体现了**“对修改关闭，对扩展开放”**原则，客户端增加行为不用修改原有代码，只要添加一种策略(或者行为)即可，避免了使用多重转移语句(if..else if..else)。
4. 提供了可以替换继承关系的办法：策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。
5. 需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大。




## 职责链模式

### OA系统采购审批需求

**学校OA系统的采购审批项目：需求是**

1. 采购员采购教学器材。
2. 如果金额小于等于5000，由教学主任审批。
3. 如果金额小于等于10000，由院长审批。
4. 如果金额小于等于30000，由副校长审批。
5. 如果金额超过30000以上，有校长审批。
6. 类图![image-20210915132118158](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210915132118158.png)

### 职责链模式

**基本介绍**

1. 职责链模式(Chain of Responsibility Pattern)，又叫责任链模式，为请求**创建了一个接收者对象的链(简单示意图)**。这种模式对请求的发送者和接收者进行解耦。![image-20210915123042598](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210915123042598.png)
2. 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
3. 这种类型的设计模式属于行为型模式。
4. 类图![image-20210915124138096](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210915124138096.png)

**对原理类图的说明-即(职责链模式的角色及职责)**

1. Handler：抽象的处理者，定义了一个处理请求的接口，同时含有另外Handler。
2. ConcreteHandlerA，B：是具体的处理者，处理它自己负责的请求，可以访问它的后继者 (即下一个处理者)，如果可以处理当前请求，则处理，否则就将该请求交给后继者去处理，从而形成-个职责链。
3. Request：含义很多属性，表示一个请求。

### 职责链模式在SpringMVC框架应用的源码分析

**职责链模式在SpringMVC框架应用的源码分析**

1. SpringMVC-HandlerExecutionChain类就使用到职责链模式
2. SpringMVC请求流程简图
3. 代码分析+Debug源码+说明![image-20210915135445385](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210915135445385.png)
    ![image-20210915132604430](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210915132604430.png)

**说明**

1. Springmvc请求的流程图中，执行了拦截器相关方法interceptor. preHandler等等。
2. 在处理SpringMvc请求时，使用到职责链模式还使用到适配器模式。
3. HandlerExecutionChain 主要负责的是请求拦截器的执行和请求处理，但是他本身不处理请求，只是将请求分配给链上注册处理器执行，这是职责链实现方式，减少职责链本身与处理逻辑之间的耦合，规范了处理流程。
4. HandlerExecutionChain 维护了HandlerInterceptor的集合，可以向其中注册相应的拦截器。

### 职责链模式的注意事项和细节

1. 将请求和处理分开，实现解耦，提高系统的灵活性。
2. 简化了对象，使对象不需要知道链的结构。
3. **性能会受到影响，特别是在链比较长的时候**，因此需控制链中最大节点数量，一般通过在**Handler中设置一个最大节点数量**，在setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系統性能。
4. 调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂。
5. 最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、Java Web中Tomcat对Encoding的处理、拦截器。



















































































































