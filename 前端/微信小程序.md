[toc]



# 小程序的注册

[小程序 (qq.com)](https://mp.weixin.qq.com/wxopen/waregister?action=step1)

# 安装开发者工具

[稳定版 Stable Build | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)

# 登录开发者工具

![image-20210818153851467](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210818153851467.png)

# 第一个小程序

## 新建小程序项目

![image-20210818154217882](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210818154217882.png)

## 查看

![image-20210818155016392](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210818155016392.png)

## 小程序的目录结构

小程序包含一个描述整体程序的 `app` 和多个描述各自页面的 `page`。

一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：

| 文件                                                         | 必需 | 作用             |
| :----------------------------------------------------------- | :--- | :--------------- |
| [app.js](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html) | 是   | 小程序逻辑       |
| [app.json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html) | 是   | 小程序公共配置   |
| [app.wxss](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html) | 否   | 小程序公共样式表 |

一个小程序页面由四个文件组成，分别是：

| 文件类型                                                     | 必需 | 作用       |
| :----------------------------------------------------------- | :--- | :--------- |
| [js](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html) | 是   | 页面逻辑   |
| [wxml](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/) | 是   | 页面结构   |
| [json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#页面配置) | 否   | 页面配置   |
| [wxss](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html) | 否   | 页面样式表 |

**注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名**

## 允许上传的文件

在项目目录中，以下文件会经过编译，因此上传之后无法直接访问到：*.js、app.json、*.wxml、*.wxss（其中 wxml 和 wxss 文件仅针对在 app.json 中配置了的页面）。除此之外，只有后缀名在白名单内的文件可以被上传，不在白名单列表内文件在开发工具能被访问到，但无法被上传。具体白名单列表如下：

wxs、png、jpg、jpeg、gif、svg、json、cer、mp3、aac、m4a、mp4、wav、ogg、silk、wasm、br

# 小程序的代码构成

## `.json` 后缀的 `JSON` 配置文件

我们可以看到在项目的根目录有一个 `app.json` 和 `project.config.json`，此外在 `pages/logs` 目录下还有一个 `logs.json`，我们依次来说明一下它们的用途。

### 小程序配置 app.json

`app.json` 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的 `app.json` 配置内容如下：

详细配置请参考： [小程序的配置 app.json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html)

配置好路径后保存，就会新建对应的页面的所有需要的配置。只在微信开发者工具中有效

```json
{
  // 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
  //定义小程序所有页面的顶部背景颜色，文字颜色定义等
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  },
  //在配置tabbar时，程序的主页面必须配置
    "tabBar": {
    "list": [
      {
      "pagePath": "pages/index/index",
      "text": "index",
      "iconPath": "",//未选中的图标
      "selectedIconPath": ""//选中的图标
      },
      {
      "pagePath": "pages/demo/demo",
      "text": "demo",
      "iconPath": "",
      "selectedIconPath": ""
      }
    ]
  },
}
```

### 工具配置 project.config.json

针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等

小程序开发者工具在每个项目的根目录都会生成一个 `project.config.json`，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置

详细配置请参考：[开发者工具的配置](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)

### 页面配置 page.json

这里的 `page.json` 其实用来表示 pages/logs 目录下的 `logs.json` 这类和小程序页面相关的配置。

如果你整个小程序的风格是蓝色调，那么你可以在 `app.json` 里边声明顶部颜色是蓝色即可。

但是你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 `page.json`，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。

详细配置请参考： [页面配置](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#页面配置) 。

### JSON 语法

JSON文件都是被包裹在一个大括号中 {}，通过key-value的方式来表达数据。JSON的Key必须包裹在一个双引号中

JSON的值**只能**是以下几种**数据格式**，其他任何格式都会触发报错，例如 JavaScript 中的 undefined。

1. 数字，包含浮点数和整数
2. 字符串，需要包裹在双引号中
3. Bool值，true 或者 false
4. 数组，需要包裹在方括号中 []
5. 对象，需要包裹在大括号中 {}
6. Null

还需要注意的是 JSON 文件中无法使用注释，试图添加注释将会引发报错。

## `.wxml` 后缀的 `WXML` 模板文件

网页编程采用的是 HTML + CSS + JS 这样的组合

同样道理，在小程序中也有同样的角色，其中 `WXML` 充当的就是类似 `HTML` 的角色。打开 `pages/index/index.wxml`，你会看到以下的内容:

```html
<view class="container">
  <view class="userinfo">
    <button wx:if="{{!hasUserInfo && canIUse}}"> 获取头像昵称 </button>
    <block wx:else>
      <image src="{{userInfo.avatarUrl}}" background-size="cover"></image>
      <text class="userinfo-nickname">{{userInfo.nickName}}</text>
    </block>
  </view>
  <view class="usermotto">
    <text class="user-motto">{{motto}}</text>
  </view>
</view>
```

#### wxml文件和 `HTML` 非常相似，`WXML` 由标签、属性等等构成。但是也有很多不一样的地方

1. 标签名字有点不一样

   写 HTML 时，经常会用到的标签是 `div`, `p`, `span`，既然大家都需要这些组件，就把这些常用的组件包装起来，大大提高开发效率。

   从上边的例子可以看到，小程序的 `WXML` 用的标签是 `view`, `button`, `text` 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。

   更多详细的组件讲述参考： [小程序的能力](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html)

2. 多了一些 `wx:if` 这样的属性以及 {{ }} 这样的表达式

   在网页的一般开发流程中，我们通常会通过 `JS` 操作 `DOM` ，以引起界面的一些变化响应用户的行为。

   但小程序的框架也是用到的是跟Vue相同的MVVM思路，提倡把渲染和逻辑分离。

   如果你需要把一个 `Hello World` 的字符串显示在界面上。

   WXML 是这么写 :

   ```html
   <text>{{msg}}</text>
   ```

   JS 只需要管理状态即可:

   ```js
   this.setData({ msg: "Hello World" })
   ```

   通过 {{ }} 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 `if`/`else`, `for`等控制能力，在小程序里边，这些控制能力都用 `wx:` 开头的属性来表达

更详细的文档可以参考： [WXML](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/)

## `.wxss` 后缀的 `WXSS` 样式文件

`WXSS` 具有 `CSS` 大部分的特性，并作出了扩充和修改

1. 新增了尺寸单位。

   在写 `CSS` 样式时，需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，我们采用一些技巧来换算一些像素单位。`WXSS` 在底层支持新的尺寸单位 `rpx` ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，

   **由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。**

2. 提供了全局的样式和局部样式。

   和前边 `app.json`, `page.json` 的概念相同，你可以写一个 `app.wxss` 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 `page.wxss` 仅对当前页面生效。

3. 此外 `WXSS` 仅支持部分 `CSS` 选择器

更详细的文档可以参考 [WXSS](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html) 。

## `.js` 后缀的 `JS` 脚本逻辑文件

在小程序里边，我们就通过编写 `JS` 脚本文件来处理用户的操作。

```html
<view>{{ msg }}</view>
<button bindtap="clickMe">点击我</button>
```

点击 `button` 按钮的时候，我们希望把界面上 `msg` 显示成 `"Hello World"`，于是我们在 `button` 上声明一个属性: `bindtap` ，在 JS 文件里边声明了 `clickMe` 方法来响应这次点击操作：

```js
Page({
  clickMe: function() {
    this.setData({ msg: "Hello World" })
  }
})
```

更详细的事件可以参考文档： [WXML - 事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)

此外你还可以在 JS 中调用小程序提供的丰富的 API，例如获取用户信息、本地存储、微信支付等。

在 `pages/index/index.js` 就调用了 [wx.getUserInfo](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html) 获取微信用户的头像和昵称，最后通过 `setData` 把获取到的信息显示到界面上。更多 API 可以参考文档 [小程序的API](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html) 。

# 小程序宿主环境

我们称微信客户端给小程序所提供的环境为宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能

## 渲染层和逻辑层

其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。

小程序的渲染层和逻辑层分别由2个线程管理：

- 渲染层的界面使用了WebView 进行渲染；
- 逻辑层采用JsCore线程运行JS脚本。

一个小程序存在多个界面，一个界面就是一个WebView线程，这两个线程的通信会经由微信客户端（Native）做中转，逻辑层发送网络请求也经由Native转发

小程序的通信模型下图所示。

![image-20210818163546891](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210818163546891.png)

有关渲染层和逻辑层的详细文档参考： [小程序框架](https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html)

## 程序与页面

### 微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地

紧接着通过 `app.json` 的 `pages` 字段就可以知道你当前小程序的所有页面路径：相当于vue-router

```json
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ]
}
```

当前说明存在`pages/index/index` 和 `pages/logs/logs`两个页面。

而写在 `pages` 字段的**第一个页面**就是这个小程序的**首页**（打开小程序看到的第一个页面）。

### 小程序启动之后

在 `app.js` 定义的 `App` 实例的 `onLaunch` 回调就会被执行:

```javascript
App({
  onLaunch: function () {
    // 小程序启动之后 触发
  	console.log("hello");
  }
})
```

整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 [注册程序 App](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html) 。

### 接下来我们简单看看小程序的一个页面是怎么写的。

可以观察到 `pages/logs/logs` 下其实是包括了4种文件

微信客户端会先根据 `logs.json` 配置生成一个界面，顶部的颜色和文字你都可以在这个 `json` 文件里边定义好

紧接着客户端就会装载这个页面的 `WXML` 结构和 `WXSS` 样式

最后客户端会装载 `logs.js`

你可以看到 `logs.js` 的大体内容就是:

```javascript
Page({
  data: { // 参与页面渲染的数据
    logs: []
  },
  onLoad: function () {
    // 页面渲染后 执行
  }
})
```

`Page` 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 `data` 数据和 `index.wxml` 一起渲染出最终的结构，于是就得到了你看到的小程序的样子

有关于 `Page` 构造器更多详细的文档参考： [注册页面 Page](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html) 

## 组件

小程序提供了丰富的基础组件给开发者，你只需要在 `WXML` 写上对应的组件标签名字就可以把该组件显示在界面上

例如，你需要在界面上显示地图，你只需要这样写即可：

```html
<map></map>
```

![image-20210818174133100](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210818174133100.png)

使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现

例如，我们希望地图一开始的中心的经纬度是广州，那么你需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:

```html
<map longitude="广州经度" latitude="广州纬度"></map>
```

组件的内部行为也会通过事件的形式让开发者可以感知。

例如用户点击了地图上的某个标记，你可以在 `js` 编写 `markertap` 函数来处理：

```html
<map bindmarkertap="markertap" longitude="广州经度" latitude="广州纬度"></map>
```

当然你也可以通过 `style` 或者 `class` 来控制组件的外层样式，以便适应你的界面宽度高度等等。

更多的组件可以参考： [小程序的组件](https://developers.weixin.qq.com/miniprogram/dev/component/)

### API

为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。

使用API需要在`.json`文件中声明，获取权限：

在app.json中定义获取用户地理位置的权限

```json
  "permission": {
    "scope.userLocation": {
      "desc": "你的位置信息将用于小程序位置接口的效果展示"
    }
  }
```

要获取用户的地理位置时，只需要：

```javascript
wx.getLocation({
  type: 'wgs84',
  success: (res) => {
    var latitude = res.latitude // 纬度
    var longitude = res.longitude // 经度
  }
})
```

调用微信扫一扫能力，只需要：

```javascript
wx.scanCode({
  success: (res) => {
    console.log(res)
  }
})
```

**需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题**

更多的 API 能力见： [小程序的API](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html)。

# 小程序协同工作和发布

 ## 协同工作

![image-20210818180612169](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210818180612169.png)

项目管理成员负责统筹整个项目的进展和风险、把控小程序对外发布的节奏

产品组提出需求

设计组与产品讨论并对需求进行抽象,设计出可视化流程与图形，输出设计方案。

开发组依据设计方案，进行程序代码的编写

代码编写完成后，产品组与设计组体验小程序的整体流程

测试组编写测试用例并对小程序进行各种边界测试

![image-20210818180758740](https://zym-notes.oss-cn-shenzhen.aliyuncs.com/img/image-20210818180758740.png)

### 小程序成员管理

小程序成员管理包括对小程序项目成员及体验成员的管理。

- 项目成员：表示参与小程序开发、运营的成员，可登录小程序管理后台，包括运营者、开发者及数据分析者。管理员可在“成员管理”中添加、删除项目成员，并设置项目成员的角色。
- 体验成员：表示参与小程序内测体验的成员，可使用体验版小程序，但不属于项目成员。管理员及项目成员均可添加、删除体验成员。

不同项目成员拥有不同的权限，从而保证小程序开发安全有序。

| 权限           | 运营者 | 开发者 | 数据分析者 |
| :------------- | :----- | :----- | :--------- |
| 开发者权限     |        | √      |            |
| 体验者权限     | √      | √      | √          |
| 登录           | √      | √      | √          |
| 数据分析       |        |        | √          |
| 微信支付       | √      |        |            |
| 推广           | √      |        |            |
| 开发管理       | √      |        |            |
| 开发设置       |        | √      |            |
| 暂停服务       | √      |        |            |
| 解除关联公众号 | √      |        |            |
| 腾讯云管理     |        | √      |            |
| 小程序插件     | √      |        |            |
| 游戏运营管理   | √      |        |            |

各权限功能说明

- 开发者权限：可使用小程序开发者工具及开发版小程序进行开发
- 体验者权限：可使用体验版小程序
- 登录：可登录小程序管理后台，无需管理员确认
- 数据分析：使用小程序统计模块功能查看小程序数据
- 微信支付：使用小程序微信支付（虚拟支付）模块
- 推广：使用小程序流量主、广告主模块
- 开发管理：小程序提交审核、发布、回退
- 开发设置：设置小程序服务器域名、消息推送及扫描普通链接二维码打开小程序
- 暂停服务设置：暂停小程序线上服务
- 解除关联公众号：可解绑小程序已关联的公众号
- 小程序插件：可进行小程序插件开发管理和设置
- 游戏运营管理：可使用小游戏管理后台的素材管理、游戏圈管理等功能

需要留意，项目管理者控制整个小程序的发布、回退、下架等敏感操作，不应把敏感操作的权限分配给不相关人员

## 小程序的版本

一般的软件开发流程，开发者编写代码自测开发版程序，直到程序达到一个稳定可体验的状态时，开发者会把这个体验版本给到产品经理和测试人员进行体验测试，最后修复完程序的Bug后发布供外部用户正式使用。

小程序的版本根据这个流程设计了小程序版本的概念:

| 权限       | **说明**                                                     |
| :--------- | :----------------------------------------------------------- |
| 开发版本   | 使用开发者工具，可将代码上传到开发版本中。 开发版本只保留每人最新的一份上传的代码。 点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。 |
| 体验版本   | 可以选择某个开发版本作为体验版，并且选取一份体验版。         |
| 审核中版本 | 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。 |
| 线上版本   | 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。 |

考虑到项目是协同开发的模式，一个小程序可能同时由多个开发者进行开发，往往开发者在小程序开发者工具上编写完代码后需要到手机进行真机体验，所以每个开发者拥有自己对应的一个开发版本。因为处于开发中的版本是不稳定的，开发者随时会修改代码覆盖开发版

为了让测试和产品经理有一个完整稳定的版本可以体验测试，小程序平台允许把其中一个开发版本设置成体验版，因此建议在项目开发阶段特殊分配一个开发角色，用于上传稳定可供体验测试的代码，并把他上传的开发版本设置成体验版

## 发布上线

一个小程序从开发完到上线一般要经过 预览-> 上传代码 -> 提交审核 -> 发布等步骤

详情请看：[小程序发布上线](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/release.html#发布上线)

## 运营数据

有两种方式可以方便的看到小程序的[运营数据](https://developers.weixin.qq.com/miniprogram/analysis/index.html)

方法一：

登录 [小程序管理后台](https://mp.weixin.qq.com/) - 数据分析

点击相应的 tab 可以看到相关的数据。

方法二：

使用小程序数据助手，在微信中方便的查看运营数据

# 小程序的配置

## 全局配置

根目录下的 `app.json` 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等

完整配置项说明请参考：[小程序全局配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)

## 页面配置

每一个小程序页面也可以使用同名 `.json` 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 `app.json` 的 `window` 中相同的配置项完整配置项说明请参考：[小程序页面配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)

例如：

```json
{
  "navigationBarBackgroundColor": "#ffffff",
  "navigationBarTextStyle": "black",
  "navigationBarTitleText": "微信接口功能演示",
  "backgroundColor": "#eeeeee",
  "backgroundTextStyle": "light"
}
```

## sitemap配置

微信现已开放小程序内搜索，开发者可以通过 `sitemap.json` 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引

具体配置说明

1. 页面收录设置：可对整个小程序的索引进行关闭，小程序管理后台-功能-页面内容接入-页面收录开关；[详情](https://mp.weixin.qq.com/wxopen/readtemplate?t=config/collection_agreement_tmpl)
2. sitemap 配置：可对特定页面的索引进行关闭

小程序根目录下的 `sitemap.json` 文件用来配置小程序及其页面是否允许被微信索引

完整配置项说明请参考：[小程序 sitemap 配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html)

**注：`sitemap` 的索引提示是默认开启的，如需要关闭 `sitemap` 的索引提示，可在小程序项目配置文件 `project.config.json` 的 `setting` 中配置字段 `checkSiteMap` 为 `false`**

**注: `sitemap` 文件内容最大为 5120 个 UTF8 字符**

#  组件

官方文档：[微信组件](https://developers.weixin.qq.com/miniprogram/dev/component/)

## 视图容器

### view 

视图容器

```html
<!--使用flex做横向或纵向布局需要使用 display:flex 声明-->
<view style="display:flex;flex-direction:row;">
  <view style="width: 50px;height: 10px;background-color: pink;"></view>
  <view style="width: 50px;height: 10px;background-color: aqua;"></view>
  <view style="width: 50px;height: 10px;background-color: bisque;"></view>
</view>
<view class="viewtest" hover-class="test" hover-start-time="10" bindtap="viewclick">
```

| 属性                   | 类型    | 默认值 | 必填 | 说明                                                         |
| :--------------------- | :------ | :----- | :--- | :----------------------------------------------------------- |
| hover-class            | string  | none   | 否   | 指定按下去的样式类。当 `hover-class="none"` 时，没有点击态效果 |
| hover-stop-propagation | boolean | false  | 否   | 指定是否阻止本节点的祖先节点出现点击态                       |
| hover-start-time       | number  | 50     | 否   | 按住后多久出现点击态，单位毫秒                               |
| hover-stay-time        | number  | 400    | 否   | 手指松开后点击态保留时间，单位毫秒                           |

### cover-view 

覆盖在原生组件之上的文本视图。可以使用view代替

| 属性       | 类型          | 必填 | 说明                                                         |
| :--------- | :------------ | :--- | :----------------------------------------------------------- |
| scroll-top | number/string | 否   | 设置顶部滚动偏移量，仅在设置了 overflow-y: scroll 成为滚动元素后生效 |

### scroll-view 

可滚动视图区域

使用竖向滚动时，需要给 scroll-view 一个固定高度

详细属性信息请查看：[scroll-view](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html)

```html
<scroll-view style="height: 100px;width: auto;background-color: burlywood;" scroll-y="true">
  <view>aaaaaaaaaaaaaaa</view>
  <view>aaaaaaaaaaaaaaa</view>
  <view>aaaaaaaaaaaaaaa</view>
  <view>aaaaaaaaaaaaaaa</view>
  <view>aaaaaaaaaaaaaaa</view>
  <view>aaaaaaaaaaaaaaa</view>
</scroll-view>
```

| 常用属性        | 类型          | 默认值 | 必填 | 说明                                       |
| :-------------- | :------------ | :----- | :--- | :----------------------------------------- |
| scroll-x        | boolean       | false  | 否   | 允许横向滚动                               |
| scroll-y        | boolean       | false  | 否   | 允许纵向滚动                               |
| upper-threshold | number/string | 50     | 否   | 距顶部/左边多远时，触发 scrolltoupper 事件 |
| lower-threshold | number/string | 50     | 否   | 距底部/右边多远时，触发 scrolltolower 事件 |
| scroll-top      | number/string |        | 否   | 设置竖向滚动条位置                         |
| scroll-left     | number/string |        | 否   | 设置横向滚动条位置                         |

### movable-view 

可移动的视图容器

在页面中可以拖拽滑动。[movable-view](https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html)必须在 [movable-area](https://developers.weixin.qq.com/miniprogram/dev/component/movable-area.html) 组件中，并且必须是直接子节点，否则不能移动

更多属性看：[movable-view](https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html)

```html
<movable-area style="height: 100px;width: auto;background-color: chartreuse;">
  <movable-view class="test" direction="all"></movable-view>
</movable-area>
```

| 属性          | 类型        | 默认值 | 必填 | 说明                                                         |
| :------------ | :---------- | :----- | :--- | :----------------------------------------------------------- |
| direction     | string      | none   | 否   | movable-view的移动方向，属性值有all、vertical、horizontal、none |
| out-of-bounds | boolean     | false  | 否   | 超过可移动区域后，movable-view是否还可以移动                 |
| disabled      | boolean     | false  | 否   | 是否禁用                                                     |
| scale         | boolean     | false  | 否   | 是否支持双指缩放，默认缩放手势生效区域是在movable-view内     |
| bindchange    | eventhandle |        | 否   | 拖动过程中触发的事件，event.detail = {x, y, source}          |

### movable-area 

`movable-view`的可移动区域。

| 属性       | 类型    | 默认值 | 必填 | 说明                                                         |
| :--------- | :------ | :----- | :--- | :----------------------------------------------------------- |
| scale-area | Boolean | false  | 否   | 当里面的movable-view设置为支持双指缩放时，设置此值可将缩放手势生效区域修改为整个movable-area |

### cover-image 

覆盖在原生组件之上的图片视图，cover-image 与image相同

```html
<image class="image" src="./images/a.png" bindload="success" binderror="failure"></image>  
<cover-image class="image" src="./images/a.png" bindload="success" binderror="failure"></cover-image>
```

| 属性      | 类型        | 必填 | 说明                                                         |
| :-------- | :---------- | :--- | :----------------------------------------------------------- |
| src       | string      | 否   | 图标路径，支持临时路径、网络地址（1.6.0起支持）、云文件ID（2.2.3起支持）。 |
| bindload  | eventhandle | 否   | 图片加载成功时触发                                           |
| binderror | eventhandle | 否   | 图片加载失败时触发                                           |

支持 jpg、png、webp、gif 格式为文件

### match-media

匹配检测节点。可以指定一组 media query 规则，满足时，这个节点才会被展示。

通过这个节点可以实现“页面宽高在某个范围时才展示某个区域”这样的效果。

```html
<match-media min-width="10" max-width="20">
  <view>当页面宽度在 10 ~ 20 px 之间时展示这里</view>
</match-media>
```

| 属性        | 类型   | 必填 | 说明                                    |
| :---------- | :----- | :--- | :-------------------------------------- |
| min-width   | number | 否   | 页面最小宽度（ px 为单位）              |
| max-width   | number | 否   | 页面最大宽度（ px 为单位）              |
| width       | number | 否   | 页面宽度（ px 为单位）                  |
| min-height  | number | 否   | 页面最小高度（ px 为单位）              |
| max-height  | number | 否   | 页面最大高度（ px 为单位）              |
| height      | number | 否   | 页面高度（ px 为单位）                  |
| orientation | string | 否   | 屏幕方向（ `landscape` 或 `portrait` ） |

### page-container

页面容器

如在页面内弹出半屏的弹窗、在页面内加载一个全屏的子页面等，用户进行返回操作会直接离开当前页面

页面内存在该容器时，当用户进行返回操作，关闭该容器不关闭页面。

返回操作包括三种情形，右滑手势、安卓物理返回键和调用 `navigateBack` 接口。

```html
<button bindtap="show">点击弹广告</button>
<page-container show="{{show}}" position="center">
  <view class="detail-page">
    <button type="primary" bindtap="exit">推出</button>
  </view>
</page-container>
```

```javascript
const app = getApp()
Page({
  data:{
    show:false
  },
  show(){
    this.setData({
      show:true
    })
  },
  exit(){
    this.setData({show:false})
  }
})
```

更多属性请看：[page-container ](https://developers.weixin.qq.com/miniprogram/dev/component/page-container.html)

| 属性     | 类型    | 默认值 | 必填 | 说明                                               | 最低版本                                                     |
| :------- | :------ | :----- | :--- | :------------------------------------------------- | :----------------------------------------------------------- |
| show     | boolean | false  | 否   | 是否显示容器组件                                   | [2.16.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| duration | number  | 300    | 否   | 动画时长，单位毫秒                                 | [2.16.](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| position | string  | bottom | 否   | 弹出位置，可选值为 `top` `bottom` `right` `center` | [2.16.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

### share-element

共享元素。

共享元素是一种动画形式，表现为元素像是在页面间穿越一样。该组件需与 [page-container](https://developers.weixin.qq.com/miniprogram/dev/component/page-container.html) 组件结合使用。

使用时需在当前页放置 `share-element` 组件，同时在 `page-container` 容器中放置对应的 `share-element` 组件，对应关系通过属性值 `key` 映射。

当设置 `page-container` 显示时，`transform` 属性为 `true` 的共享元素会产生动画。当前页面容器退出时，会产生返回动画。

```html

<share-element key="aaa" transform>
  <view class="detail-page">
    <button type="primary" bindtap="exit">推出</button>
  </view>
</share-element>


<page-container show="{{show}}" position="center">
<view>
  <share-element key="aaa" transform>
  <view class="detail-page">
    <button type="primary" bindtap="exit">推出</button>
  </view>
</share-element>
</view>
<view>
ok
</view>
</page-container>
```

| 属性            | 类型    | 默认值   | 必填 | 说明               |
| :-------------- | :------ | :------- | :--- | :----------------- |
| key             | string  |          | 是   | 映射标记           |
| transform       | boolean | false    | 否   | 是否进行动画       |
| duration        | number  | 300      | 否   | 动画时长，单位毫秒 |
| easing-function | string  | ease-out | 否   | `css`缓动函数      |

### swiper

滑块视图容器。其中只可放置[swiper-item](https://developers.weixin.qq.com/miniprogram/dev/component/swiper-item.html)组件，否则会导致未定义的行为。

```html
<swiper indicator-dots = "true" indicator-active-color="red">
<swiper-item  style="width: 20px;height: 20px;background-color: aqua;">A</swiper-item>
<swiper-item  style="width: 20px;height: 20px;background-color:salmon;">B</swiper-item>
<swiper-item  style="width: 20px;height: 20px;background-color: yellow;">C</swiper-item>
</swiper>
```

详细属性参考：[swiper](https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html)

| 属性            | 类型    | 默认值            | 必填 | 说明               |
| :-------------- | :------ | :---------------- | :--- | :----------------- |
| indicator-dots  | boolean | false             | 否   | 是否显示面板指示点 |
| indicator-color | color   | rgba(0, 0, 0, .3) | 否   | 指示点颜色         |

### swiper-item

仅可放置在[swiper](https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html)组件中，宽高自动设置为100%。

| 属性                    | 类型    | 默认值 | 必填 | 说明                                                         |
| :---------------------- | :------ | :----- | :--- | :----------------------------------------------------------- |
| item-id                 | string  |        | 否   | 该 swiper-item 的标识符                                      |
| skip-hidden-item-layout | boolean | false  | 否   | 是否跳过未显示的滑块布局，设为 true 可优化复杂情况下的滑动性能，但会丢失隐藏状态滑块的布局信息 |

## 基础内容

### icon 图标

```html
<icon type="success" color="yello"></icon>
```

| 属性  | 类型          | 默认值 | 必填 | 说明                                                         |
| :---- | :------------ | :----- | :--- | :----------------------------------------------------------- |
| type  | string        |        | 是   | icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear |
| size  | number/string | 23     | 否   | icon的大小                                                   |
| color | string        |        | 否   | icon的颜色，同css的color                                     |

### progress 进度条

```html
<progress percent="100" duration="500" show-info="true" active="true"></progress>
```

| 属性      | 类型    | 默认值 | 必填 | 说明                   |
| :-------- | :------ | :----- | :--- | :--------------------- |
| percent   | number  |        | 否   | 百分比0~100            |
| show-info | boolean | false  | 否   | 在进度条右侧显示百分比 |

### rich-text 富文本

```html
<view class="page-content">
  <view>
  {{text}}
  </view>
  <button style="margin: 30rpx 0" type="primary" bindtap="renderNode">渲染Node</button>
  <block wx:if="{{renderedByNode}}">
    <rich-text nodes="{{text}}"></rich-text>
  </block>
</view>
```

```javascript
Page({
  data:{
    text:`<h1>title</h1>`,
    renderedByNode : false
  },
  renderNode(){
    this.setData({renderedByNode:true})
  }
})
```

| 属性  | 类型         | 默认值 | 必填 | 说明                 |
| :---- | :----------- | :----- | :--- | :------------------- |
| nodes | array/string | []     | 否   | 节点列表/HTML String |
| space | string       |        | 否   | 显示连续空格         |

### text 文本

```html
<text>我是你爹</text>
```

| 属性        | 类型    | 默认值 | 必填 | 说明                                                |
| :---------- | :------ | :----- | :--- | :-------------------------------------------------- |
| selectable  | boolean | false  | 否   | 文本是否可选 (已废弃)                               |
| user-select | boolean | false  | 否   | 文本是否可选，该属性会使文本节点显示为 inline-block |
| space       | string  |        | 否   | 显示连续空格                                        |
| decode      | boolean | false  | 否   | 是否解码                                            |

## 表单组件

### button 按钮

```html
<button size="mini" type="primary" plain="true" >按钮</button>
```

| 属性      | 类型    | 默认值  | 必填 | 说明                                                         |
| :-------- | :------ | :------ | :--- | :----------------------------------------------------------- |
| size      | string  | default | 否   | 按钮的大小                                                   |
| type      | string  | default | 否   | 按钮的样式类型                                               |
| plain     | boolean | false   | 否   | 按钮是否镂空，背景色透明                                     |
| disabled  | boolean | false   | 否   | 是否禁用                                                     |
| form-type | string  |         | 否   | 用于 [form](https://developers.weixin.qq.com/miniprogram/dev/component/form.html) 组件，点击分别会触发 [form](https://developers.weixin.qq.com/miniprogram/dev/component/form.html) 组件的 submit/reset 事件 |

### checkbox 多选框

```html
<checkbox id="test">好的</checkbox>
```

| 属性     | 类型    | 默认值  | 必填 | 说明                                                         |
| :------- | :------ | :------ | :--- | :----------------------------------------------------------- |
| value    | string  |         | 否   | [checkbox](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox.html)标识，选中时触发[checkbox-group](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox-group.html)的 change 事件，并携带 [checkbox](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox.html) 的 value |
| disabled | boolean | false   | 否   | 是否禁用                                                     |
| checked  | boolean | false   | 否   | 当前是否选中，可用来设置默认选中                             |
| color    | string  | #09BB07 | 否   | checkbox的颜色，同css的color                                 |

### checkbox-group

多项选择器，内部由多个[checkbox](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox.html)组成。

```html
<checkbox-group id="test" bindchange="change">
<checkbox value="篮球">篮球</checkbox>
<checkbox value="羽毛球">羽毛球</checkbox>
<checkbox value="乒乓球">乒乓球</checkbox>
</checkbox-group>
<view>{{data}}</view>
```

```javascript
Page({
  data: {
    data:['hello','aaa']
  }, 
    change(e){
    var res = e.detail.value;
    this.setData({data:res})
  }
```

| 属性       | 类型        | 必填 | 说明                                                         |
| :--------- | :---------- | :--- | :----------------------------------------------------------- |
| bindchange | EventHandle | 否   | [checkbox-group](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox-group.html)中选中项发生改变时触发 change 事件，detail = {value:[选中的checkbox的value的数组]} |

### editor

富文本编辑器，可以对图片、文字进行编辑。

编辑器导出内容支持带标签的 `html`和纯文本的 `text`，编辑器内部采用 `delta` 格式进行存储。

富文本组件内部引入了一些基本的样式使得内容可以正确的展示，开发时可以进行覆盖。需要注意的是，在其它组件或环境中使用富文本组件导出的html时，需要额外引入 [这段样式](data:application/zip;base64,UEsDBBQAAAAIAPmAhU999kpyHAYAAI4lAAAKAAAAZWRpdG9yLmNzc7Va7ZKbIBT935m+g51OZ3c7647J5qt22hdp+4MoiXQJWCTdbHf67r1CFBUjamyns4YLHO45XC5E8vCL+hFnEhGGhff69o3nxSRLKXoJvS3l0dPn3JTyjEjCWegJTJEkv7Eyb/nJz8gfwvYhfBYxFj6YVJX/jLdPRPrHDIwZpjiSoSfxSaradis/SgpuhB7jDGvLbyx2lD+HXkLiGDNlfCaxTEJvFgQfVDnBZJ8AzjwIUj34gTC/af379k2N6zeN+KPG+Ty03drLSzgmkoNIHYrsoEMuCZAgLMGCaGY5rbNHZYVpv0MHQl/KigaF0t5F3hhSFMdqQoKagv6p0LBuhmHRUfLanEmU+gnA0hwaNKBcwCwJxLIUCcxkvTE/RokfIUph+kr9TH05UhYJTqlyTfXpVjkMzwDnfluUC28ECLx35JByIRGT3UgPGsCHKUZbiuMcxo6sSxjkgPZYkYDwaMTKjuJTY3mgbcbpUTqXhy7CtKUnL0ZZAm69j6JI1f08ZpLsXpQjmIGmEfzFQtUhmBPmE4kPWWG/uNzMXFjWfmxLi4poTd6mWo+6BRDa6GWoFravPK75ukXR017wI4uL2Hq/2+1UVVHebDaWTDAa0Sq5xOUpioiECQoeNIzQa2RR+MVTVWiu2Nlc28wME6ZWrkqEZvnpJTNUQ8m5iWI7fVxQzMXViAmyBYFa9EUbgWJyhDhZnmlV1G5SD+y8WQj0xycsxieVYsZyhsTBvNduaaOjyHL3Uk4K4iaslhdny7BVfptQUTyvcTikKIP0lxAKOcMe6CoxHqQgiO0p9o8pgNt5215nJnT9kjrFO/BkqVO/TtE7Lg7nbE0RxNOtD9V31eANahtHLWLOLVZ1ZTP5QnGoVa3a7Z2h9nlLITarlqGCJYjFtCvvGBa5IoZjWbaXQvDhisRSWWwXo4sc9q5IP6CTX93HDQol6ZYjEXsQFLql2BNWTJIJkaKLOZNc9tw6JthnrctHAom25+W20PvMgf/xK8Zm1lIRqScigV3Kh5mPoF0qsP8sUKprwDVVAi8FRk9+brAYffU+AiuTF9QoVqv0vlbktF4+1su5H3WDmpRfRy4b9mTWKM8b5cdGedEoLxvllXNCgSlElsyDFWdYgpQE0s9MP+b68agfC/1Y6sdKP9b6sdGPT6VURhvvK9Q1BNJG5ZzqqBe7L19SExt/27qE4RZDrjkvz/KscvN9HsznNy29vsVIIkinOHrC8RcpjvjHfWeTHaIZ1ufzYlPw8W8YJdOe9RtD8/vYayjdtH1EOOAOGLBQp/ewRs7qTr1er1v3xukctKdvNZu5py/3vAdSYCOZDh1p0s4gjOv8YVL8HB9aYlwF8/9YTAaRsEjgQ05S1wbtbrTKUoDc6p73Xowj2OzonXfz4N20A0FZHcFYTuC1y5OZG6CHV7N7D7YBgEc0TdA4z7TqV8jdPdq8W4e5G6CHDvNCB8EPiPXUYd6mw/QCPHYL8OgG6CHA49DwfGwjPyHrRTfrhRugB+vFmPBftDGfgvKym/LSDdCD8nJMpC/bKF/FddXNdeUG6MF1NTSoV208xxFcdxNcuwF6EFyPid91G8mB7Dbd7DZugB7sNmNCddPGri+tT+20BgD0oPXJFZW1PZxxeZsbYiJwlH8r9oWEjtX3CH7+Raz1kATOTQhWhbJQwKC/F+p3JjVMZerl4WSw1W16AO1Fq4cTglWhRpF1ezgZbHW3H0B71erhhGBVqFFk3R5OBls9NwygvWn1cEKwKtQosm4PJ4OtHkQG0J4FrS5OiVbFGkW3h4/T4VYPOkOYO9P21WhVrHF83T5Oh1s9Sw1h7kzdV6NVscbxdfs4HW711DaEuTN9X41WxRrH1+3jdLjV8+cQ5s4UfjVaFWscX7eP0+FaSLpraQo9sDVuQcpfbFhoxg19u6vB7Fvfjo7nXwfYPc8VVtcGdbujMje75Z/gAo89tb6YFvstuoW3l+f/D6u7z7XvNkhKcateGKcUXt8mnMJl1F15g1vcKBIJLkSfL73gv3QRat+6QcH8vuPya+v6C+s+NwvmRu7V3Lf6syD/lzau1s5lc49W/LbEeaG7LC4B/wFQSwECPwAUAAAACAD5gIVPffZKchwGAACOJQAACgAkAAAAAAAAACAAAAAAAAAAZWRpdG9yLmNzcwoAIAAAAAAAAQAYAENPshVDq9UBQ0+yFUOr1QFDT7IVQ6vVAVBLBQYAAAAAAQABAFwAAABEBgAAAAA=)，并维护`<ql-container><ql-editor></ql-editor></ql-container>`的结构。

图片控件仅初始化时设置有效。

```html
<editor id="edi" placeholder="请输入" bindinput="edi" style="width: auto;height: 100px;"></editor>
<button bindtap="fwb" type="primary">确定</button>
```

```html
Page({
  data: {
    text:"111"
  },
  edi(e){
    var text = e.detail.text;
    console.log(text);
    this.setData({text:text})
  },
  fwb(){
    console.log(this.data.text);
  },
```

### form 表单

| 属性                  | 类型        | 默认值 | 必填 | 说明                                                         |
| :-------------------- | :---------- | :----- | :--- | :----------------------------------------------------------- |
| report-submit         | boolean     | false  | 否   | 是否返回 formId 用于发送[模板消息](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/template-message.html) |
| report-submit-timeout | number      | 0      | 否   | 等待一段时间（毫秒数）以确认 formId 是否生效。如果未指定这个参数，formId 有很小的概率是无效的（如遇到网络失败的情况）。指定这个参数将可以检测 formId 是否有效，以这个参数的时间作为这项检测的超时时间。如果失败，将返回 requestFormId:fail 开头的 formId |
| bindsubmit            | eventhandle |        | 否   | 携带 form 中的数据触发 submit 事件，event.detail = {value : {'name': 'value'} , formId: ''} |
| bindreset             | eventhandle |        | 否   | 表单重置时会触发 reset 事件                                  |

### input 输入框

| 属性     | 类型    | 默认值 | 必填 | 说明             |
| :------- | :------ | :----- | :--- | :--------------- |
| value    | string  |        | 是   | 输入框的初始内容 |
| type     | string  | text   | 否   | input 的类型     |
| password | boolean | false  | 否   | 是否是密码类型   |

### label

用来改进表单组件的可用性

使用for属性找到对应的id，或者将控件放在该标签下，当点击时，就会触发对应的控件。 for优先级高于内部控件，内部有多个控件的时候默认触发第一个控件。 目前可以绑定的控件有：[button](https://developers.weixin.qq.com/miniprogram/dev/component/button.html), [checkbox](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox.html), [radio](https://developers.weixin.qq.com/miniprogram/dev/component/radio.html), [switch](https://developers.weixin.qq.com/miniprogram/dev/component/switch.html)。

```html
<label for="od" style="background-color: aquamarine;width: auto;height: 20px;">
label
</label>
```

### picker

从底部弹起的滚动选择器

```html
  <picker mode="date" value="{{date}}" start="2015-09-01" end="2017-09-01" bindchange="bindDateChange">
    <view class="picker">
      当前选择: {{date}}
    </view>
  </picker>
```

| 属性        | 类型        | 默认值   | 必填 | 说明                     |
| :---------- | :---------- | :------- | :--- | :----------------------- |
| header-text | string      |          | 否   | 选择器的标题，仅安卓可用 |
| mode        | string      | selector | 否   | 选择器类型               |
| disabled    | boolean     | false    | 否   | 是否禁用                 |
| bindcancel  | eventhandle |          | 否   | 取消选择时触发           |

### picker-view

嵌入页面的滚动选择器。其中只可放置 [picker-view-column](https://developers.weixin.qq.com/miniprogram/dev/component/picker-view-column.html)组件，其它节点不会显示。

| 属性            | 类型           | 必填 | 说明                                                         |
| :-------------- | :------------- | :--- | :----------------------------------------------------------- |
| value           | Array.<number> | 否   | 数组中的数字依次表示 picker-view 内的 picker-view-column 选择的第几项（下标从 0 开始），数字大于 picker-view-column 可选项长度时，选择最后一项。 |
| indicator-style | string         | 否   | 设置选择器中间选中框的样式                                   |
| indicator-class | string         | 否   | 设置选择器中间选中框的类名                                   |

### picker-view-column

滚动选择器子项。仅可放置于[picker-view](https://developers.weixin.qq.com/miniprogram/dev/component/picker-view.html)中，其孩子节点的高度会自动设置成与[picker-view](https://developers.weixin.qq.com/miniprogram/dev/component/picker-view.html)的选中框的高度一致

```html
<picker-view indicator-style="height: 50px;" style="width: 100%; height: 300px;" value="{{value}}" bindchange="bindChange">
      <picker-view-column>
        <view>a</view>
        <view>b</view>
      </picker-view-column>
      <picker-view-column>
        <view wx:for="{{item}}" wx:key="{{item}}" style="line-height: 50px; text-align: center;">{{item}}年</view>
      </picker-view-column>
</picker-view>
```

```javascript
Page({
  data: {
    item:[111,222,333,444,555]
  },
})
```

### radio

单选项目。

```html
<radio-group bindchange="rad">
<radio value="a">aaaaaaa</radio>
<radio value="b">bbbbbbbbbb</radio>
<radio value="c">ccccccccc</radio>
</radio-group>
```

```javascript
Page({
  rad(e){
    console.log(e.detail.value);
  }
})
```

| 属性     | 类型    | 默认值  | 必填 | 说明                                                         |
| :------- | :------ | :------ | :--- | :----------------------------------------------------------- |
| value    | string  |         | 否   | [radio](https://developers.weixin.qq.com/miniprogram/dev/component/radio.html) 标识。当该[radio](https://developers.weixin.qq.com/miniprogram/dev/component/radio.html) 选中时，[radio-group](https://developers.weixin.qq.com/miniprogram/dev/component/radio-group.html) 的 change 事件会携带[radio](https://developers.weixin.qq.com/miniprogram/dev/component/radio.html)的value |
| checked  | boolean | false   | 否   | 当前是否选中                                                 |
| disabled | boolean | false   | 否   | 是否禁用                                                     |
| color    | string  | #09BB07 | 否   | radio的颜色，同css的color                                    |

### radio-group

单项选择器，内部由多个 [radio](https://developers.weixin.qq.com/miniprogram/dev/component/radio.html) 组成。

| 属性       | 类型        | 必填 | 说明                                                         |
| :--------- | :---------- | :--- | :----------------------------------------------------------- |
| bindchange | EventHandle | 否   | [radio-group](https://developers.weixin.qq.com/miniprogram/dev/component/radio-group.html)中选中项发生改变时触发 change 事件，detail = {value:[选中的radio的value的数组]} |

### slider

滑动选择器

```html
<slider min="0" max="100"></slider>
```

| 属性     | 类型    | 默认值 | 必填 | 说明                                          |
| :------- | :------ | :----- | :--- | :-------------------------------------------- |
| min      | number  | 0      | 否   | 最小值                                        |
| max      | number  | 100    | 否   | 最大值                                        |
| step     | number  | 1      | 否   | 步长，取值必须大于 0，并且可被(max - min)整除 |
| disabled | boolean | false  | 否   | 是否禁用                                      |

### switch

开关选择器

```html
<switch checked="true"></switch>
```

| 属性       | 类型        | 默认值  | 必填 | 说明                                                  |
| :--------- | :---------- | :------ | :--- | :---------------------------------------------------- |
| checked    | boolean     | false   | 否   | 是否选中                                              |
| disabled   | boolean     | false   | 否   | 是否禁用                                              |
| type       | string      | switch  | 否   | 样式，有效值：switch, checkbox                        |
| color      | string      | #04BE02 | 否   | switch 的颜色，同 css 的 color                        |
| bindchange | eventhandle |         | 否   | checked 改变时触发 change 事件，event.detail={ value} |

### textarea

多行输入框。该组件是[原生组件](https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html)，使用时请注意相关限制。

| 属性        | 类型   | 必填 | 说明               |
| :---------- | :----- | :--- | :----------------- |
| value       | string | 否   | 输入框的内容       |
| placeholder | string | 否   | 输入框为空时占位符 |

## 导航

### functional-page-navigator

仅在插件中有效，用于跳转到插件功能页。

| 属性        | 类型         | 默认值  | 必填 | 说明                                                       |
| :---------- | :----------- | :------ | :--- | :--------------------------------------------------------- |
| version     | string       | release | 否   | 跳转到的小程序版本，**线上版本必须设置为 release**         |
| name        | string       |         | 否   | 要跳转到的功能页                                           |
| args        | object       |         | 否   | 功能页参数，参数格式与具体功能页相关                       |
| bindsuccess | eventhandler |         | 否   | 功能页返回，且操作成功时触发， detail 格式与具体功能页相关 |
| bindfail    | eventhandler |         | 否   | 功能页返回，且操作失败时触发， detail 格式与具体功能页相关 |
| bindcancel  | eventhandler |         | 否   | 因用户操作从功能页返回时触发                               |

### navigator

页面链接

```html
<navigator url="/pages/demo1/demo1" >跳转到新页面</navigator>
```

| 属性      | 类型   | 默认值   | 必填 | 说明                                 |
| :-------- | :----- | :------- | :--- | :----------------------------------- |
| target    | string | self     | 否   | 在哪个目标上发生跳转，默认当前小程序 |
| url       | string |          | 否   | 当前小程序内的跳转链接               |
| open-type | string | navigate | 否   | 跳转方式                             |

## 媒体组件

### audio

音频

| 属性     | 类型    | 默认值 | 必填 | 说明                   |
| :------- | :------ | :----- | :--- | :--------------------- |
| id       | string  |        | 否   | audio 组件的唯一标识符 |
| src      | string  |        | 否   | 要播放音频的资源地址   |
| loop     | boolean | false  | 否   | 是否循环播放           |
| controls | boolean | false  | 否   | 是否显示默认控件       |

### camera

系统相机。扫码二维码功能，需升级微信客户端至6.7.3。需要[用户授权](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html) `scope.camera`

| 属性            | 类型   | 默认值 | 必填 | 说明                                     |
| :-------------- | :----- | :----- | :--- | :--------------------------------------- |
| mode            | string | normal | 否   | 应用模式，只在初始化时有效，不能动态变更 |
| resolution      | string | medium | 否   | 分辨率，不支持动态修改                   |
| device-position | string | back   | 否   | 摄像头朝向                               |
| flash           | string | auto   | 否   | 闪光灯，值为auto, on, off                |

### image 图片

支持 JPG、PNG、SVG、WEBP、GIF 等格式，2.3.0起支持云文件ID。

```html
<image class="image" src="./images/a.png" bindload="success" binderror="failure"></image> 
```

| 属性                   | 类型        | 默认值      | 必填 | 说明                                                         |
| :--------------------- | :---------- | :---------- | :--- | :----------------------------------------------------------- |
| src                    | string      |             | 否   | 图片资源地址                                                 |
| mode                   | string      | scaleToFill | 否   | 图片裁剪、缩放的模式                                         |
| webp                   | boolean     | false       | 否   | 默认不解析 webP 格式，只支持网络资源                         |
| lazy-load              | boolean     | false       | 否   | 图片懒加载，在即将进入一定范围（上下三屏）时才开始加载       |
| show-menu-by-longpress | boolean     | false       | 否   | 长按图片显示发送给朋友、收藏、保存图片、搜一搜、打开名片/前往群聊/打开小程序（若图片中包含对应二维码或小程序码）的菜单 |
| binderror              | eventhandle |             | 否   | 当错误发生时触发，event.detail = {errMsg}                    |
| bindload               | eventhandle |             | 否   | 当图片载入完毕时触发，event.detail = {height, width}         |

### live-player

实时音视频播放

需要先通过类目审核，再在小程序管理后台，「开发」-「接口设置」中自助开通该组件权限

### live-pusher

实时音视频录制

### video

视频

| 属性       | 类型           | 默认值 | 必填 | 说明                                                         |
| :--------- | :------------- | :----- | :--- | :----------------------------------------------------------- |
| src        | string         |        | 是   | 要播放视频的资源地址，支持网络路径、本地临时路径、云文件ID（[2.3.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)） |
| duration   | number         |        | 否   | 指定视频时长                                                 |
| controls   | boolean        | true   | 否   | 是否显示默认播放控件（播放/暂停按钮、播放进度、时间）        |
| danmu-list | Array.<object> |        | 否   | 弹幕列表                                                     |
| danmu-btn  | boolean        | false  | 否   | 是否显示弹幕按钮，只在初始化时有效，不能动态变更             |

### voip-room

多人音视频对话

## 地图

### map 地图

| 属性               | 类型    | 默认值 | 必填 | 说明                     |
| :----------------- | :------ | :----- | :--- | :----------------------- |
| longitude          | number  |        | 是   | 中心经度                 |
| latitude           | number  |        | 是   | 中心纬度                 |
| scale              | number  | 16     | 否   | 缩放级别，取值范围为3-20 |
| show-compass       | boolean | false  | 否   | 显示指南针               |
| enable-overlooking | boolean | false  | 否   | 开启俯视                 |

## 画布

### canvas

| 属性            | 类型        | 默认值 | 必填 | 说明                                                         |
| :-------------- | :---------- | :----- | :--- | :----------------------------------------------------------- |
| type            | string      |        | 否   | 指定 canvas 类型，支持 2d (2.9.0) 和 webgl (2.7.0)           |
| canvas-id       | string      |        | 否   | canvas 组件的唯一标识符，若指定了 type 则无需再指定该属性    |
| disable-scroll  | boolean     | false  | 否   | 当在 canvas 中移动时且有绑定手势事件时，禁止屏幕滚动以及下拉刷新 |
| bindtouchstart  | eventhandle |        | 否   | 手指触摸动作开始                                             |
| bindtouchmove   | eventhandle |        | 否   | 手指触摸后移动                                               |
| bindtouchend    | eventhandle |        | 否   | 手指触摸动作结束                                             |
| bindtouchcancel | eventhandle |        | 否   | 手指触摸动作被打断，如来电提醒，弹窗                         |
| bindlongtap     | eventhandle |        | 否   | 手指长按 500ms 之后触发，触发了长按事件后进行移动不会触发屏幕的滚动 |
| binderror       | eventhandle |        | 否   | 当发生错误时触发 error 事件，detail = {errMsg}               |

## 开放能力

| 名称                                                         | 功能说明               |
| :----------------------------------------------------------- | :--------------------- |
| [web-view](https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html) | 承载网页的容器         |
| [ad](https://developers.weixin.qq.com/miniprogram/dev/component/ad.html) | Banner 广告            |
| [ad-custom](https://developers.weixin.qq.com/miniprogram/dev/component/ad-custom.html) | 原生模板 广告          |
| [official-account](https://developers.weixin.qq.com/miniprogram/dev/component/official-account.html) | 公众号关注组件         |
| [open-data](https://developers.weixin.qq.com/miniprogram/dev/component/open-data.html) | 用于展示微信开放的数据 |

## 原生组件

#### 原生组件说明

小程序中的部分组件是由客户端创建的原生组件，这些组件有：

[camera](https://developers.weixin.qq.com/miniprogram/dev/component/camera.html)

[canvas](https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html)

[input](https://developers.weixin.qq.com/miniprogram/dev/component/input.html)（仅在focus时表现为原生组件）

[live-player](https://developers.weixin.qq.com/miniprogram/dev/component/live-player.html)

[live-pusher](https://developers.weixin.qq.com/miniprogram/dev/component/live-pusher.html)

[map](https://developers.weixin.qq.com/miniprogram/dev/component/map.html)

[textarea](https://developers.weixin.qq.com/miniprogram/dev/component/textarea.html)

[video](https://developers.weixin.qq.com/miniprogram/dev/component/video.html)

同层渲染是为了解决原生组件的层级问题，在支持同层渲染后，原生组件与其它组件可以随意叠加，有关层级的限制将不再存在 

#### 原生组件的使用限制

*除事件相关，同层渲染下已无以下限制**

由于原生组件脱离在 WebView 渲染流程外，因此在使用时有以下限制：

- 原生组件的层级是最高的，所以页面中的其他组件无论设置`z-index` 为多少，都无法盖在原生组件上。
  - 后插入的原生组件可以覆盖之前的原生组件。
- 原生组件还无法在picker-view中使用。
  - 基础库 2.4.4 以下版本，原生组件不支持在 [scroll-view](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html)、[swiper](https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html)、[movable-view](https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html) 中使用。
- 部分 CSS 样式无法应用于原生组件，例如：
  - 无法对原生组件设置 CSS 动画
  - 无法定义原生组件为 `position: fixed`
  - 不能在父级节点使用 `overflow: hidden` 来裁剪原生组件的显示区域
- 原生组件的事件监听不能使用 `bind:eventname` 的写法，只支持 `bindeventname`。原生组件也不支持 catch 和 capture 的事件绑定方式。
- 原生组件会遮挡 vConsole 弹出的调试面板。 *在工具上，原生组件是用web组件模拟的，因此很多情况并不能很好的还原真机的表现，建议开发者在使用到原生组件时尽量在真机上进行调试。*

## 无障碍访问

| 名称                                                         | 功能说明      |
| :----------------------------------------------------------- | :------------ |
| [aria-component](https://developers.weixin.qq.com/miniprogram/dev/component/aria-component.html) | ## 无障碍访问 |
| 为了更好地满足视障人士对于小程序的访问需求，基础库自2.7.1起，支持部分ARIA标签 |               |

## 导航栏

### navigation-bar

页面导航条配置节点，用于指定导航栏的一些属性。只能是 [page-meta](https://developers.weixin.qq.com/miniprogram/dev/component/page-meta.html) 组件内的第一个节点

```html
<page-meta>
  <navigation-bar title="拍照"></navigation-bar>
</page-meta>
```

| 属性             | 类型    | 默认值 | 必填 | 说明                                                         |
| :--------------- | :------ | :----- | :--- | :----------------------------------------------------------- |
| title            | string  |        | 否   | 导航条标题                                                   |
| loading          | boolean | false  | 否   | 是否在导航条显示 loading 加载提示                            |
| front-color      | string  |        | 否   | 导航条前景颜色值，包括按钮、标题、状态栏的颜色，仅支持 `#ffffff` 和 `#000000` |
| background-color | string  |        | 否   | 导航条背景颜色值，有效值为十六进制颜色                       |

## 页面属性配置节点

### page-meta

页面属性配置节点，用于指定页面的一些属性、监听页面事件。只能是页面内的第一个节点。可以配合 [navigation-bar](https://developers.weixin.qq.com/miniprogram/dev/component/navigation-bar.html) 组件一同使用。

通过这个节点可以获得类似于调用 [wx.setBackgroundTextStyle](https://developers.weixin.qq.com/miniprogram/dev/api/ui/background/wx.setBackgroundTextStyle.html) [wx.setBackgroundColor](https://developers.weixin.qq.com/miniprogram/dev/api/ui/background/wx.setBackgroundColor.html) 等接口调用的效果。

| 属性                    | 类型   | 必填 | 说明                                                         |
| :---------------------- | :----- | :--- | :----------------------------------------------------------- |
| background-text-style   | string | 否   | 下拉背景字体、loading 图的样式，仅支持 `dark` 和 `light`     |
| background-color        | string | 否   | 窗口的背景色，必须为十六进制颜色值                           |
| background-color-top    | string | 否   | 顶部窗口的背景色，必须为十六进制颜色值，仅 iOS 支持          |
| background-color-bottom | string | 否   | 底部窗口的背景色，必须为十六进制颜色值，仅 iOS 支持          |
| root-background-color   | string | 否   | 页面内容的背景色，用于页面中的空白部分和页面大小变化 resize 动画期间的临时空闲区域 |

# 自定义组件

小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本 [1.6.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 或更高

开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似

## 创建自定义组件

类似于页面，一个自定义组件由 `json` `wxml` `wxss` `js` 4个文件组成。

要编写一个自定义组件，首先需要在 `json` 文件中进行自定义组件声明（将 `component` 字段设为 `true` 可将这一组文件设为自定义组件）：

```json
{
  "component": true
}
```

同时，还要在 `wxml` 文件中编写组件模板，在 `wxss` 文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见 [组件模板和样式](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html) 

**注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器**

在自定义组件的 `js` 文件中，需要使用 `Component()` 来注册组件，并提供组件的属性定义、内部数据和自定义方法

属性值是可由组件外部传入的，更多细节参见 [Component构造器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html)

```js
Component({
  properties: {
    // 这里定义了innerText属性，属性值可以在组件使用时指定
    innerText: {
      type: String,
      value: 'default value',
    }
  },
  data: {
    // 这里是一些组件内部数据
    someData: {}
  },
  methods: {
    // 这里是一个自定义方法
    customMethod: function(){}
  }
})
```

## 使用自定义组件

使用已注册的自定义组件前，首先要在页面的 `json` 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径

```json
{
  "usingComponents": {
    "component-tag-name": "path/to/the/custom/component"
  }
}
```

这样，在页面的 `wxml` 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

```html
<view>
  <!-- 以下是对一个自定义组件的引用 -->
  <component-tag-name inner-text="Some text"></component-tag-name>
</view>
```

## 注意：

- 因为 WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
- 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 `usingComponents` 字段）。
- 自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。

注意，是否在页面文件中使用 `usingComponents` 会使得页面的 `this` 对象的原型稍有差异，包括：

- 使用 `usingComponents` 页面的原型与不使用时不一致，即 `Object.getPrototypeOf(this)` 结果不同。
- 使用 `usingComponents` 时会多一些方法，如 `selectComponent` 。
- 出于性能考虑，使用 `usingComponents` 时， `setData` 内容不会被直接深复制，即 `this.setData({ field: obj })` 后 `this.data.field === obj` 。（深复制会在这个值被组件间传递时发生。）

## 组件模板和样式

类似于页面，自定义组件拥有自己的 `wxml` 模板和 `wxss` 样式

### 组件模板

组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

在组件模板中可以提供一个 `<slot>` 节点（即vue中的插槽），用于承载组件引用时提供的子节点

注意，在模板中引用到的自定义组件及其对应的节点名需要在 `json` 文件中显式定义

```html
<!--模板文件-->
<view>
{{name}}
<slot></slot>
</view>
```

```html
<!--在组件的slot中插入标签会或子组件-->
<cpn name="我是你爹">
<view>儿子好</view>
</cpn>
```

#### 具名插槽

定义具名插槽

```html
<view>
{{name}}
<slot name="a"></slot>
<slot name="b"></slot>
</view>

```

使用多个插槽时，需要在定义插槽的组件中声明：

```javascript
Component({  
  options: {
    multipleSlots: true
  }
})
```

通过插槽的name区分使用的是哪一个组件

```html
<cpn name="我是你爹">
<view slot="b">儿子好</view>
<button slot="a">hello</button>
</cpn>
```

#### 数据传递-父传子

与普通的 WXML 模板类似，可以使用数据绑定，这样就可以向子组件的属性传递动态数据

直接通过属性值传递的方式，前面创建自定义组件有了解

### 组件样式

组件对应 `wxss` 文件的样式，只对组件wxml内的节点生效。编写组件样式时，需要注意以下几点：

- 组件和引用组件的页面不能使用id选择器（`#a`）、属性选择器（`[a]`）和标签名选择器，请改用class选择器。
- 组件和引用组件的页面中使用后代选择器（`.a .b`）在一些极端情况下会有非预期的表现，如遇，请避免使用。
- 子元素选择器（`.a>.b`）只能用于 `view` 组件与其子节点之间，用于其他组件可能导致非预期的情况。
- 继承样式，如 `font` 、 `color` ，会从组件外继承到组件内。
- 除继承样式外， `app.wxss` 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。

除此以外，组件可以指定它所在节点的默认样式，使用 `:host` 选择器（需要包含基础库 [1.7.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 或更高版本的开发者工具支持）

```css
/* 组件 custom-component.wxss */
:host {
  color: yellow;
}
```

#### 组件的样式隔离

默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：

- `app.wxss` 或页面的 `wxss` 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。
- 指定特殊的样式隔离选项 `styleIsolation` 。

```javascript
Component({
  options: {
    styleIsolation: 'isolated'
  }
})
```

`styleIsolation` 选项从基础库版本 [2.6.5](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始支持。它支持以下取值：

- `isolated` 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；
- `apply-shared` 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；
- `shared` 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 `apply-shared` 或 `shared` 的自定义组件。（这个选项在插件中不可用。

也可以在页面或自定义组件的 json 文件中配置 `styleIsolation` （这样就不需在 js 文件的 `options` 中再配置）。例如：

```json
{
  "styleIsolation": "isolated"
}
```

#### 外部样式类

组件希望接受外部传入的样式类。此时可以在 `Component` 中用 `externalClasses` 定义段定义若干个外部样式类

**注意：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况**

**代码示例：**

```js
/* 组件 custom-component.js */
Component({
  externalClasses: ['my-class']
})
<!-- 组件 custom-component.wxml -->
<custom-component class="my-class">这段文本的颜色由组件外的 class 决定</custom-component>
```

**代码示例：**

```html
<!-- 页面的 WXML -->
<custom-component my-class="red-text" />
<custom-component my-class="large-text" />
<!-- 以下写法需要基础库版本 2.7.1 以上 -->
<custom-component my-class="red-text large-text" />
```

```css
.red-text {
  color: red;
}
.large-text {
  font-size: 1.5em;
}
```

#### 引用页面或父组件的样式

即使启用了样式隔离 `isolated` ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。

例如，如果在页面 wxss 中定义了：

```css
.blue-text {
  color: blue;
}
```

在这个组件中可以使用 `~` 来引用这个类的样式：

```html
<view class="~blue-text"> 这段文本是蓝色的 </view>
```

如果在一个组件的父组件 wxss 中定义了：

```css
.red-text {
  color: red;
}
```

在这个组件中可以使用 `^` 来引用这个类的样式：

```html
<view class="^red-text"> 这段文本是红色的 </view>
```

也可以连续使用多个 `^` 来引用祖先组件中的样式。

**注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式**

#### 虚拟化组件节点

默认情况下，自定义组件本身的那个节点是一个“普通”的节点，使用时可以在这个节点上设置 `class` `style` 、动画、 flex 布局等，就如同普通的 view 组件节点一样。

但有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex 布局等，而是希望自定义组件内部的第一层节点能够响应 flex 布局或者样式由自定义组件本身完全决定。

这种情况下，可以将这个自定义组件设置为“虚拟的”：

```javascript
Component({
  options: {
    virtualHost: true
  }
})
```

这样，可以将 flex 放入自定义组件内：

```html
<!-- 页面的 WXML -->
<view style="display: flex">
  <!-- 如果设置了 virtualHost ，节点上的样式将失效 -->
  <custom-component style="color: blue">不是蓝色的</custom-component>
</view>
```

```html
<!-- custom-component.wxml -->
<view style="flex: 1">
  满宽的
  <slot></slot>
</view>
```

需要注意的是，自定义组件节点上的 `class` `style` 和动画将不再生效，但仍可以：

- 将 style 定义成 `properties` 属性来获取 style 上设置的值；
- 将 class 定义成 `externalClasses` 外部样式类使得自定义组件 wxml 可以使用 class 值。

## Component 构造器

`Component` 构造器可用于定义组件，调用 `Component` 构造器时可以指定组件的属性、数据、方法等。

详细的参数含义和使用请参考: [Component 参考文档](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html)

### 使用 Component 构造器构造页面

小程序的页面也可以视为自定义组件。因而，页面也可以使用 `Component` 构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 json 文件中包含 `usingComponents` 定义段。

```json
{
  "usingComponents": {}
}
```

此时，组件的属性可以用于接收页面的参数，如访问页面 `/pages/index/index?paramA=123&paramB=xyz` ，如果声明有属性 `paramA` 或 `paramB` ，则它们会被赋值为 `123` 或 `xyz` 。

页面的生命周期方法（即 `on` 开头的方法），应写在 `methods` 定义段中。

**代码示例：**

```json
Component({
  properties: {
    paramA: Number,
    paramB: String,
  },

  methods: {
    onLoad: function() {
      this.data.paramA // 页面参数 paramA 的值
      this.data.paramB // 页面参数 paramB 的值
    }
  }

})
```

使用 `Component` 构造器来构造页面的一个好处是可以使用 `behaviors` 来提取所有页面中公用的代码段。

例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 `behaviors` 中。

**具体做法在后面的小程序框架，注册页面中记录**

## 组件间通信与事件

### 组件间通信

组件间的基本通信方式有以下几种。

- WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 [2.0.9](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始，还可以在数据中包含函数）。具体在 [组件模板](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html) 章节中介绍。
- 事件：用于子组件向父组件传递数据，可以传递任意数据。
- 如果以上两种方式不足以满足需要，父组件还可以通过 `this.selectComponent` 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法

### 触发事件

在组件中通过函数触发事件

```javascript
Component({
  properties: {},
  methods: {
    onTap: function(){
      let myEventDetail = {"name":this.data.name,"test":this.data.test}
      let myEventOption = {}
      //事件名称：btn
      //传递给事件监听函数的对象，（就是需要传递给父组件的数据或方法）myEventDetail
      // 触发事件的选项 myEventOption
      this.triggerEvent('btn', myEventDetail, myEventOption)
    }
  }
})
```

触发事件的选项包括：

| 选项名       | 类型    | 是否必填 | 默认值 | 描述                                                         |
| :----------- | :------ | :------- | :----- | :----------------------------------------------------------- |
| bubbles      | Boolean | 否       | false  | 事件是否冒泡                                                 |
| composed     | Boolean | 否       | false  | 事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部 |
| capturePhase | Boolean | 否       | false  | 事件是否拥有捕获阶段                                         |

### 监听事件

事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见 [事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html) 。

监听自定义组件事件的方法与监听基础组件事件的方法完全一致

在自定义组件使用时，通过bind监听对应的事件

```html
<!--btn是子组件触发的事件名称，eventbtn是当btn事件触发后调用的方法-->
<cpn name="我是你爹" bind:btn="eventbtn">
<view slot="b">儿子好</view>
<button slot="a">hello</button>
</cpn>
```

```javascript
Page({
  eventbtn: function(e){
    e.detail // 自定义组件触发事件时提供的detail对象
  }
})
```

### 获取组件实例

可在父组件里调用 `this.selectComponent` ，获取子组件的实例对象。

调用时需要传入一个匹配选择器 `selector`，如：`this.selectComponent(".my-component")`。

`selector` 详细语法可查看 [selector 语法参考文档](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.select.html)

```html
<cpn name="我是你爹" bind:btn="eventbtn" class="cc"></cpn>
<button bindtap="test">test</button>
```

```javascript
  test(){
    let cpn = this.selectComponent(".cc");
    cpn.btn();
    console.log(cpn.method);
  }
```

在上例中，父组件将会获取 `class` 为 `my-component` 的子组件实例对象，即子组件的 `this`

### 自定义的组件实例获取结果

若需要自定义 `selectComponent` 返回的数据，可使用内置 `behavior`: `wx://component-export`

使用该 behavior 时，自定义组件中的 `export` 定义段将用于指定组件被 `selectComponent` 调用时的返回值

```javascript
Component({
  behaviors:["wx://component-export"],
  export(){
    return {myname:"myname"}
  }
})
```

```javascript
test(){
    let cpn = this.selectComponent(".cc");
    console.log(cpn.myname);	//myname
  }
```

## 组件生命周期

组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

其中，最重要的生命周期是 `created` `attached` `detached` ，包含一个组件实例生命流程的最主要时间点。

- 组件实例刚刚被创建好时， `created` 生命周期被触发。此时，组件数据 `this.data` 就是在 `Component` 构造器中定义的数据 `data` 。 **此时还不能调用 `setData` 。** 通常情况下，这个生命周期只应该用于给组件 `this` 添加一些自定义属性字段。
- 在组件完全初始化完毕、进入页面节点树后， `attached` 生命周期被触发。此时， `this.data` 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
- 在组件离开页面节点树后， `detached` 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 `detached` 会被触发

#### 使用方法

```js
Component({
  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    },
  }
}）
```

在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors 中的同名生命周期相互覆盖。

但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次

可用的全部生命周期如下表所示。

| 生命周期 | 参数           | 描述                                     |
| :------- | :------------- | :--------------------------------------- |
| created  | 无             | 在组件实例刚刚被创建时执行               |
| attached | 无             | 在组件实例进入页面节点树时执行           |
| ready    | 无             | 在组件在视图层布局完成后执行             |
| moved    | 无             | 在组件实例被移动到节点树另一个位置时执行 |
| detached | 无             | 在组件实例被从页面节点树移除时执行       |
| error    | `Object Error` | 每当组件方法抛出错误时执行               |

#### 组件所在页面的生命周期

还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 `pageLifetimes` 定义段中定义。其中可用的生命周期包括：

| 生命周期 | 参数          | 描述                         | 最低版本                                                     |
| :------- | :------------ | :--------------------------- | :----------------------------------------------------------- |
| show     | 无            | 组件所在的页面被展示时执行   | [2.2.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| hide     | 无            | 组件所在的页面被隐藏时执行   | [2.2.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
| resize   | `Object Size` | 组件所在的页面尺寸变化时执行 | [2.4.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |

使用方法：

```js
Component({
  pageLifetimes: {
    show: function() {
      // 页面被展示
    },
    hide: function() {
      // 页面被隐藏
    },
    resize: function(size) {
      // 页面尺寸变化
    }
  }
})
```

## behaviors

### 组件中使用

组件引用时，在 `behaviors` 定义段中将它们逐个列出即可

后面小程序框架的注册页面中详细记录

### 同名字段的覆盖和组合规则

组件和它引用的 `behavior` 中可以包含同名的字段，对这些字段的处理方法如下

**如果有同名的属性 (properties) 或方法 (methods)：**

1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 `behavior` 中的同名属性或方法；
2. 若组件本身无这个属性或方法，则在组件的 `behaviors` 字段中定义靠后的 `behavior` 的属性或方法会覆盖靠前的同名属性或方法；
3. 在 2 的基础上，若存在嵌套引用 `behavior` 的情况，则规则为：`父 behavior` 覆盖 `子 behavior` 中的同名属性或方法

**如果有同名的数据字段 (data)：**

- 若同名的数据字段都是对象类型，会进行对象合并；
- 其余情况会进行数据覆盖，覆盖规则为：组件 > `父 behavior` > `子 behavior` 、 `靠后的 behavior` > `靠前的 behavior`。（优先级高的覆盖优先级低的，最大的为优先级最高）

**生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：**

- 对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序；
- 对于同种生命周期函数，遵循如下规则：
  - `behavior` 优先于组件执行；
  - `子 behavior` 优先于 `父 behavior` 执行；
  - `靠前的 behavior` 优先于 `靠后的 behavior` 执行；
- 如果同一个 `behavior` 被一个组件多次引用，它定义的生命周期函数只会被执行一次

### 内置 behaviors

自定义组件可以通过引用内置的 `behavior` 来获得内置组件的一些行为。

```javascript
Component({
  behaviors: ['wx://form-field']
})
```

在上例中， `wx://form-field` 代表一个内置 `behavior` ，它使得这个自定义组件有类似于表单控件的行为。

内置 `behavior` 往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的 `type` 或添加 `observer`

#### wx://form-field

使自定义组件有类似于表单控件的行为。 form 组件可以识别这些自定义组件，并在 submit 事件中返回组件的字段名及其对应字段值。

详细用法以及代码示例可见：[form 组件参考文档](https://developers.weixin.qq.com/miniprogram/dev/component/form)

#### wx://form-field-group

从基础库版本 [2.10.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始提供支持。

使 form 组件可以识别到这个自定义组件内部的所有表单控件。

详细用法以及代码示例可见：[form 组件参考文档](https://developers.weixin.qq.com/miniprogram/dev/component/form)

#### wx://form-field-button

从基础库版本 [2.10.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始提供支持。

使 form 组件可以识别到这个自定义组件内部的 button 。如果自定义组件内部有设置了 form-type 的 button ，它将被组件外的 form 接受。

详细用法以及代码示例可见：[form 组件参考文档](https://developers.weixin.qq.com/miniprogram/dev/component/form)

#### wx://component-export

从基础库版本 [2.2.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始提供支持。

使自定义组件支持 `export` 定义段。这个定义段可以用于指定组件被 `selectComponent` 调用时的返回值。

详细用法以及代码示例可见：[selectComponent 参考文档](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events)

## 定义和使用组件间关系

### 父子组件

有时需要实现这样的组件：

```html
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
```

这个例子中， `custom-ul` 和 `custom-li` 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入 `relations` 定义段，可以解决这样的问题。示例：

在子组件中绑定父组件

```javascript
Component({
  relations:{
    'compnent-ul':{
      type:'parent',//parent表示绑定的compnent-ul是父组件
      linked: function(target) {
        // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后
      },
      linkChanged: function(target) {
        // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后
      },
      unlinked: function(target) {
        // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后
      }
    }
  }
})
```

在父组件中绑定子组件

```javascript
Component({
  relations:{
    'component-li':{
      type:"child",
      linked: function(target) {
        // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后
      },
      linkChanged: function(target) {
        // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后
      },
      unlinked: function(target) {
        // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后
      }
    }
  },
  methods: {
    _getAllLi: function(){
      // 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的
      var nodes = this.getRelationNodes('path/to/custom-li')
    }
  },
  ready: function(){
    this._getAllLi()
  }
})
```

**注意：必须在两个组件定义中都加入relations定义，否则不会生效**

### 关联一类组件

有时，需要关联的是一类组件，如：

```html
<custom-form>
  <view>
    input
    <custom-input></custom-input>
  </view>
  <custom-submit> submit </custom-submit>
</custom-form>
```

`custom-form` 组件想要关联 `custom-input` 和 `custom-submit` 两个组件。此时，如果这两个组件都有同一个behavior：

```javascript
// path/to/custom-form-controls.js
module.exports = Behavior({
  // ...
})
```

在input和submit中都关联祖先节点from

```javascript
// path/to/custom-input.js
var customFormControls = require('./custom-form-controls')
Component({
  behaviors: [customFormControls],
  relations: {
    './custom-form': {
      type: 'ancestor', // 关联的目标节点应为祖先节点
    }
  }
})
```

```javascript
// path/to/custom-submit.js
var customFormControls = require('./custom-form-controls')
Component({
  behaviors: [customFormControls],
  relations: {
    './custom-form': {
      type: 'ancestor', // 关联的目标节点应为祖先节点
    }
  }
})
```

则在 `relations` 关系定义中，可使用这个behavior（`input`和`submit`共同的`behavior`）来代替组件路径作为关联的目标节点：

```js
// path/to/custom-form.js
var customFormControls = require('./custom-form-controls')
Component({
  relations: {
    'customFormControls': {
      type: 'descendant', // 关联的目标节点应为子孙节点
      target: customFormControls
    }
  }
})
```

#### relations 定义段

`relations` 定义段包含目标组件路径及其对应选项，可包含的选项见下表。

| 选项        | 类型     | 是否必填 | 描述                                                         |
| :---------- | :------- | :------- | :----------------------------------------------------------- |
| type        | String   | 是       | 目标组件的相对关系，可选的值为 `parent` 、 `child` 、 `ancestor` 、 `descendant` |
| linked      | Function | 否       | 关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件attached生命周期之后 |
| linkChanged | Function | 否       | 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件moved生命周期之后 |
| unlinked    | Function | 否       | 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件detached生命周期之后 |
| target      | String   | 否       | 如果这一项被设置，则它表示关联的目标节点所应具有的behavior，所有拥有这一behavior的组件节点都会被关联 |

## 数据监听器

数据监听器可以用于监听和响应任何属性和数据字段的变化

### 使用数据监听器

有时，在一些数据字段被 setData 设置时，需要执行一些操作。

```javascript
Component({
  data:{
    test1:'hello',
    test2:'yes'
  },
  //数据监听器，当test1被修改时，触发后面的函数
  observers:{
    'test1，test2':function(test1,test2) {
      console.log(this.data.test1);
      console.log(this.data.test2);
    }
  },
  methods:{
    btn(){
      this.setData({test1:'我恁爹'})
    }
  }
})
```

### 监听字段语法

数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData 最多触发每个监听器一次。

监听器可以监听子数据字段，如下例所示。

```js
Component({
  observers: {
    'some.subfield': function(subfield) {
      // 使用 setData 设置 this.data.some.subfield 时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      subfield === this.data.some.subfield
    },
    'arr[12]': function(arr12) {
      // 使用 setData 设置 this.data.arr[12] 时触发
      // （除此以外，使用 setData 设置 this.data.arr 也会触发）
      arr12 === this.data.arr[12]
    },
  }
})
```

如果需要监听所有子数据字段的变化，可以使用通配符 `**` 。

```js
Component({
  observers: {
    'some.field.**': function(field) {
      // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      field === this.data.some.field
    },
  },
  attached: function() {
    // 这样会触发上面的 observer
    this.setData({
      'some.field': { /* ... */ }
    })
    // 这样也会触发上面的 observer
    this.setData({
      'some.field.xxx': { /* ... */ }
    })
    // 这样还是会触发上面的 observer
    this.setData({
      'some': { /* ... */ }
    })
  }
})
```

特别地，仅使用通配符 `**` 可以监听全部 setData 。

```js
Component({
  observers: {
    '**': function() {
      // 每次 setData 都触发
    },
  },
})
```

### 注意事项

- 数据监听器监听的是 setData 涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
- 如果在数据监听器函数中使用 setData 设置本身监听的数据字段，可能会导致死循环，需要特别留意。
- 数据监听器和属性的 observer 相比，数据监听器更强大且通常具有更好的性能。

## 纯数据字段

纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能

### 组件数据中的纯数据字段

某些 `data` 中的字段（包括 `setData` 设置的字段）**既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用**。可以指定这样的数据字段为“纯数据字段”，它们将仅仅被记录在 `this.data` 中，而不参与任何界面渲染过程，这样有助于提升页面更新性能。

指定“纯数据字段”的方法是在 `Component` 构造器的 `options` 定义段中指定 `pureDataPattern` 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。

例如：

```javascript
Component({
  options: {
    pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段
  },
  data: {
    a: true, // 普通数据字段
    _b: true, // 纯数据字段
  },
  methods: {
    myMethod() {
      this.data._b // 纯数据字段可以在 this.data 中获取
      this.setData({
        c: true, // 普通数据字段
        _d: true, // 纯数据字段
      })
    }
  }
})
```

### 组件属性中的纯数据字段

属性也可以被指定为纯数据字段（遵循 `pureDataPattern` 的正则表达式）。

属性中的纯数据字段可以像普通属性一样接收外部传入的属性值，但不能将它直接用于组件自身的 WXML 中。

**代码示例：**

```js
Component({
  options: {
    pureDataPattern: /^_/
  },
  properties: {
    a: Boolean,
    //可以接受到数据，但不能将其在wxml中使用
    _b: {
      type: Boolean,
      observer() {
        // 不要这样做！这个 observer 永远不会被触发
      }
    },
  }
})
```

注意：属性中的纯数据字段的属性 observer 永远不会触发！如果想要监听属性值变化，使用 [数据监听器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html) 代替。

可以在页面或自定义组件的 json 文件中配置 `pureDataPattern` （这样就不需在 js 文件的 `options` 中再配置）。此时，其值应当写成字符串形式：

```json
{
  "pureDataPattern": "^_"
}
```

### 使用数据监听器监听纯数据字段

[数据监听器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html) 可以用于监听纯数据字段（与普通数据字段一样）。这样，可以通过监听、响应纯数据字段的变化来改变界面

**代码示例：**

```js
Component({
  options: {
    pureDataPattern: /^timestamp$/ // 将 timestamp 属性指定为纯数据字段
  },
  properties: {
    timestamp: Number,
  },
  observers: {
    timestamp: function () {
      // timestamp 被设置时，将它展示为可读时间字符串
      var timeString = new Date(this.data.timestamp).toLocaleString()
      this.setData({
        timeString: timeString
      })
    }
  }
})
```

```html
<view>{{timeString}}</view>
```

## 抽象节点

### 在组件中使用抽象节点

有时，自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。

例如，我们现在来实现一个`component-ul`组件，它其中可以放置`component-li`，或者`component-a`

#### 设置抽象节点：

```html
<!--pages/component-ul/component-ul.wxml-->
<view>
<selectable></selectable>
</view>
```

#### 声明抽象节点

在 component-ul.json 的componentGenerics 字段中声明：

```json
{
  "componentGenerics": {
    "selectable": true
  }
}
```

### 使用包含抽象节点的组件

在使用包含抽象节点的组件时，需要先将被使用的组件定义在当前的json文件中

```json
{
  "usingComponents": {
    "ul":"../component-ul/component-ul",
    "li":"../component-li/component-li",
    "a":"../component-a/component-a"
  }
}
```

在使用 selectable-group 组件时，必须指定“selectable”具体是哪个组件

```javascript
<ul generic:selectable="li"></ul>
<ul generic:selectable="a"></ul>
```

### 抽象节点的默认组件

抽象节点可以指定一个默认组件，当具体组件未被指定时，将创建默认组件的实例。默认组件可以在 `componentGenerics` 字段中，抽象节点声明的时候指定：

```json
{
  "componentGenerics": {
    "selectable": {
      "default": "path/to/default/component"
    }
  }
}
```

### 注意事项

- 节点的 generic 引用 `generic:xxx="yyy"` 中，值 `yyy` 只能是静态值，不能包含数据绑定。因而抽象节点特性并不适用于动态决定节点名的场景。

## 自定义组件扩展

为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。

[自定义组件扩展 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/extend.html#使用扩展)

[官方扩展包](https://github.com/wechat-miniprogram/computed)

## 第三方自定义组件

[开发第三方自定义组件 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/trdparty.html)

## 插件

详情看官方文档：[插件 | 微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/)

# 小程序框架

## 场景值

场景值用来描述用户进入小程序的路径。完整场景值的含义请查看[场景值列表](https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html)。

由于Android系统限制，目前还无法获取到按 Home 键退出到桌面，然后从桌面再次进小程序的场景值，对于这种情况，会保留上一次的场景值

### 获取场景值

开发者可以通过下列方式获取场景值：

- 对于小程序，可以在 `App` 的 `onLaunch` 和 `onShow`，或[wx.getLaunchOptionsSync](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html) 中获取上述场景值。
- 对于小游戏，可以在 [wx.getLaunchOptionsSync](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html) 和 [wx.onShow](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/(wx.onShow)) 中获取上述场景值

### 返回来源信息的场景

部分场景值下还可以获取来源应用、公众号或小程序的appId。获取方式请参考对应API的参考文档。

| 场景值 | 场景                            | appId含义  |
| :----- | :------------------------------ | :--------- |
| 1020   | 公众号 profile 页相关小程序列表 | 来源公众号 |
| 1035   | 公众号自定义菜单                | 来源公众号 |
| 1036   | App 分享消息卡片                | 来源App    |
| 1037   | 小程序打开小程序                | 来源小程序 |
| 1038   | 从另一个小程序返回              | 来源小程序 |
| 1043   | 公众号模板消息                  | 来源公众号 |

## 逻辑层

在 `JavaScript` 的基础上，我们增加了一些功能，以方便小程序的开发：

- 增加 `App` 和 `Page` 方法，进行[程序注册](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html)和[页面注册](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html)。
- 增加 `getApp` 和 `getCurrentPages` 方法，分别用来获取 `App` 实例和当前页面栈。
- 提供丰富的 [API](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html)，如微信用户数据，扫一扫，支付等微信特有能力。
- 提供[模块化](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#模块化)能力，每个页面有独立的[作用域](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#文件作用域)。

**注意：小程序框架的逻辑层并非运行在浏览器中，因此 `JavaScript` 在 web 中一些能力都无法使用，如 `window`，`document` 等**

### 注册小程序

**每个小程序**都需要在 `app.js` 中调用 `App` 方法注册小程序实例

详细的参数含义和使用请参考 [App 参考文档](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html) 。

```javascript
// app.js
App({
  test(){
    console.log("Im app.js");
  }
})
```

整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 `getApp` 方法获取到全局唯一的 App 实例，获取App上的数据或调用开发者注册在 `App` 上的函数。

```javascript
// pages/demo2/demo2.js
const app = getApp();
Page({
  dyapp(){
    app.test()
  }
})
```

```html
<button bindtap="dyapp" >按钮</button>
```

### 注册页面

对于小程序中的**每个页面**，都需要在页面对应的 `js` 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等

#### 使用 Page 构造器注册页面

详细的参数含义和使用请参考: [Page 参考文档](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html) 

```javascript
// pages/demo2/demo2.js
const app = getApp();
Page({
  dyapp(){
    app.test()
  }
})
```

#### 在页面中使用 behaviors

页面可以引用 behaviors 。 behaviors 可以用来让多个页面有相同的数据字段和方法

先将共用的代码抽离为单独的js文件，公共代码需要特定的格式，比如方法必须放在method里面

<font color='red'>**注意：Behavior 不要写成 Behaviors**</font>

```javascript
// my-behavior.js
module.exports = Behavior({
  data:{
  },methods:{
    test(){
      console.log("aaa");
    }
  }
})
```

在使用共用代码的页面的json文件中定义`usingComponents`

```javascript
{
  "usingComponents": {}
}
```

引用公共代码

```javascript
var pageCommonBehavior = require('./my-behavior')
Page({
  behaviors: [pageCommonBehavior],
  data: { /* ... */ },
  btn(){
      console.log("hello")
  }
})
```

页面中的Page可以使用Component代替

```javascript
var pageCommonBehavior = require('./my-behavior.j')
Component({
  behaviors: [pageCommonBehavior],
  data: { /* ... */ },
  methods: { /* ... */ },
})
```

使用Component构造页面后，由于组件的属性可以用于接收页面的参数，如访问页面 `/pages/index/index?paramA=123&paramB=xyz` ，如果声明有属性 `paramA` 或 `paramB` ，则它们会被赋值为 `123` 或 `xyz` 。

#### 使用 Component 构造器构造页面

`Page` 构造器适用于简单的页面。但对于复杂的页面， `Page` 构造器可能并不好用。

此时，可以使用 `Component` 构造器来构造页面。 `Component` 构造器的主要区别是：方法需要放在 `methods: { }` 里面

### 页面路由

在小程序中所有页面的路由全部由框架进行管理

#### 页面栈

框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：

| 路由方式   | 页面栈表现                        |
| :--------- | :-------------------------------- |
| 初始化     | 新页面入栈                        |
| 打开新页面 | 新页面入栈                        |
| 页面重定向 | 当前页面出栈，新页面入栈          |
| 页面返回   | 页面不断出栈，直到目标返回页      |
| Tab 切换   | 页面全部出栈，只留下新的 Tab 页面 |
| 重加载     | 页面全部出栈，只留下新的页面      |

开发者可以使用 `getCurrentPages()` 函数获取当前页面栈

#### 路由方式

对于路由的触发方式以及页面生命周期函数如下：

```html
<navigator url="/pages/demo1/demo1" >跳转到新页面</navigator>
```

| 路由方式   | 触发时机                                                     | 路由前页面 | 路由后页面         |
| :--------- | :----------------------------------------------------------- | :--------- | :----------------- |
| 初始化     | 小程序打开的第一个页面                                       |            | onLoad, onShow     |
| 打开新页面 | 调用 API [wx.navigateTo](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html) 使用组件[navigatur](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) | onHide     | onLoad, onShow     |
| 页面重定向 | 调用 API [wx.redirectTo](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html) 使用组件 [navigatur](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) | onUnload   | onLoad, onShow     |
| 页面返回   | 调用 API [wx.navigateBack](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html) 使用组件[navigatur](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) 用户按左上角返回按钮 | onUnload   | onShow             |
| Tab 切换   | 调用 API [wx.switchTab](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html) 使用组件 [navigatur](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) 用户切换 Tab |            | 各种情况请参考下表 |
| 重启动     | 调用 API [wx.reLaunch](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html) 使用组件 [navigatur](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html) | onUnload   | onLoad, onShow     |

### 模块化

可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 `module.exports`或者 `exports` 才能对外暴露接口

就是js的模块化

### API

小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍请参考 [API 文档](https://developers.weixin.qq.com/miniprogram/dev/api/index.html)

通常，在小程序 API 有以下几种类型：

事件监听 API，同步 API，异步 API，异步 API 返回 Promise，云开发 API

#### 事件监听 API

我们约定，以 `on` 开头的 API 用来监听某个事件是否触发，如：[wx.onSocketOpen](https://developers.weixin.qq.com/miniprogram/dev/api/network/websocket/wx.onSocketOpen.html)，[wx.onCompassChange](https://developers.weixin.qq.com/miniprogram/dev/api/device/compass/wx.onCompassChange.html) 等。

这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。

## 视图层

### 数据绑定

使用`{{message}}`，与vue相同

### 页面渲染

循环渲染`wx:for` ，与`v-for`的表达式有一点区别

```html
<view wx:for="{{array}}"> {{item}} </view>
<!--添加wx:key="item"提高效率，值最好是item-->
<view wx:for="{{array}}" wx:key="item">{{item}}</view>
```

判断渲染`wx:if`,`wx:elif`,`wx:else`与`v-if`,`v-elif`,`v-else`相同

```html
<view wx:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view>
<view wx:elif="{{view == 'APP'}}"> APP </view>
<view wx:else="{{view == 'MINA'}}"> MINA </view>
```

### 模板

```html
<!--创建模板，name为staffName-->
<template name="staffName">
  <view>
    FirstName: {{firstName}}, LastName: {{lastName}}
  </view>
</template>
<!--
使用name为staffName的模板，通过data传入数据
当传入的数据为对象时，需要加三个点 data="{{...staffA}}"
传入的对象时普通数字会字符串时，不需要加，但获取数据的{{firstName}}要和传入时的名称一样
-->
<template is="staffName" data="{{...staffA}}"></template>
<template is="staffName" data="{{...staffB}}"></template>
<template is="staffName" data="{{...staffC}}"></template>
```

```javascript
Page({
  data: {
    staffA: {firstName: 'Hulk', lastName: 'Hu'},
    staffB: {firstName: 'Shang', lastName: 'You'},
    staffC: {firstName: 'Gideon', lastName: 'Lin'}
  }
})
```

### WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。就是css

### WXS

WXS（WeiXin Script）是小程序的一套脚本语言，结合 `WXML`，可以构建出页面的结构。

就相当于在页面中添加`script`标签，在wxs定义时，加上module属性，通过module属性名可以调用其函数，或变量等

```html
<view> {{m1.message}} </view>

<wxs module="m1">
var msg = "hello world";
module.exports.message = msg;
</wxs>
```

### 事件

#### 使用WXS函数响应事件

本方案基本的思路是减少通信的次数，让事件在视图层（Webview）响应。这个思路就必须要让开发者的代码运行在视图层（Webview）,让用户触发事件时，减少请求js代码的时间

使用 [WXS](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/) 函数用来响应小程序事件，目前只能响应内置组件的事件，不支持自定义组件事件

- 在组件中绑定和注册事件处理的WXS函数。

```html
<wxs module="wxs" src="./test.wxs"></wxs>
<view id="tapTest" data-hi="Weixin" bindtap="{{wxs.tapName}}"> Click me! </view>
**注：绑定的WXS函数必须用{{}}括起来**
```

- test.wxs文件实现tapName函数

```text
function tapName(event, ownerInstance) {
  console.log('tap Weixin', JSON.stringify(event))
}
module.exports = {
  tapName: tapName
}
```

其中入参 `event` 是小程序[事件对象](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)基础上多了 `event.instance` 来表示触发事件的组件的 `ComponentDescriptor` 实例。

`ownerInstance` 表示的是触发事件的组件所在的组件的 `ComponentDescriptor` 实例，如果触发事件的组件是在页面内的，`ownerInstance` 表示的是页面实例。

`ComponentDescriptor`的定义如下：

| 方法                          | 参数             | 描述                                                         |
| :---------------------------- | :--------------- | :----------------------------------------------------------- |
| selectComponent               | selector对象     | 返回组件的 `ComponentDescriptor` 实例。                      |
| selectAllComponents           | selector对象数组 | 返回组件的 `ComponentDescriptor` 实例数组。                  |
| setStyle                      | Object/string    | 设置组件样式，支持`rpx`。设置的样式优先级比组件 wxml 里面定义的样式高。不能设置最顶层页面的样式。 |
| addClass/removeClass/hasClass | string           | 设置组件的 class。设置的 class 优先级比组件 wxml 里面定义的 class 高。不能设置最顶层页面的 class。 |

`ownerInstance`包含了一些方法，可以设置组件的样式和class，具体包含的方法以及为什么要用WXS函数响应事件，请[点击查看详情](https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html)

#### 事件分类

事件分为冒泡事件和非冒泡事件：

1. 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。
2. 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递

WXML的冒泡事件列表：

| 类型        | 触发条件                             |
| :---------- | :----------------------------------- |
| touchstart  | 手指触摸动作开始                     |
| touchmove   | 手指触摸后移动                       |
| touchcancel | 手指触摸动作被打断，如来电提醒，弹窗 |
| touchend    | 手指触摸动作结束                     |
| tap         | 手指触摸后马上离开                   |

**注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 [form](https://developers.weixin.qq.com/miniprogram/dev/component/form.html) 的`submit`事件，[input](https://developers.weixin.qq.com/miniprogram/dev/component/input.html) 的`input`事件，[scroll-view](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html) 的`scroll`事件，(详见各个[组件](https://developers.weixin.qq.com/miniprogram/dev/component/))**

#### 普通事件绑定

事件绑定的写法类似于组件的属性，如：

```html
<view bindtap="handleTap">
    Click here!
</view>
```

事件绑定函数可以是一个数据绑定，如：

```html
<button bindtap="{{btn}}" >test</button>
<!--此时，页面的 this.data.handlerName 必须是一个字符串，指定事件处理函数名；
如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）-->
```

```javascript
Page({
  data:{
    btn:'dyapp'
  },
  dyapp(){
    console.log('aaaaaaaaaa');
    this.setData({btn : null})
  },
})
```

#### 阻止时间冒泡

除 `bind` 外，也可以用 `catch` 来绑定事件。与 `bind` 不同， `catch` 会阻止事件向上冒泡

例如在下边这个例子中，点击 inner view 会先后调用handleTap3和handleTap2(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发handleTap2，点击 outer view 会触发handleTap1。

```html
<view id="outer" bindtap="handleTap1">
  outer view
  <view id="middle" catchtap="handleTap2">
    middle view
    <view id="inner" bindtap="handleTap3">
      inner view
    </view>
  </view>
</view>
```

#### 互斥事件绑定

自基础库版本 [2.8.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 起，除 `bind` 和 `catch` 外，还可以使用 `mut-bind` 来绑定事件。一个 `mut-bind` 触发后，如果事件冒泡到其他节点上，其他节点上的 `mut-bind` 绑定函数不会被触发，但 `bind` 绑定函数和 `catch` 绑定函数依旧会被触发

#### 事件的捕获阶段

自基础库版本 [1.5.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用`capture-bind`、`capture-catch`关键字，后者将中断捕获阶段和取消冒泡阶段。

在下面的代码中，点击 inner view 会先后调用`handleTap2`、`handleTap4`、`handleTap3`、`handleTap1`。

```html
<view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2">
  outer view
  <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">
    inner view
  </view>
</view>
<!--如果将上面代码中的第一个capture-bind改为capture-catch，将只触发handleTap2。-->
```

#### 事件对象

如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

**BaseEvent 基础事件对象属性列表：**

| 属性                                                         | 类型    | 说明                           |
| :----------------------------------------------------------- | :------ | :----------------------------- |
| [type](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#type) | String  | 事件类型                       |
| [timeStamp](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#timeStamp) | Integer | 事件生成时的时间戳             |
| [target](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#target) | Object  | 触发事件的组件的一些属性值集合 |
| [currentTarget](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#currenttarget) | Object  | 当前组件的一些属性值集合       |
| [mark](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#mark) | Object  | 事件标记数据                   |

**特殊事件： [canvas](https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html) 中的触摸事件不可冒泡，所以没有 currentTarget。**

## 数据绑定

### 单向绑定

在页面使用对应js中的数据，更新input中数据时后台js中的数据不会改变

```html
<input value="{{value}}" />
```

### 双向绑定

修改input中的数据，后台也会改变

```html
<input model:value="{{value}}" />
```

用于双向绑定的表达式有如下限制：

只能是一个单一字段的绑定，如下都是非法的；

```html
<input model:value="值为 {{value}}" />
<input model:value="{{ a + b }}" />
```

目前，尚不能 data 路径，如下这样的表达式目前暂不支持

```html
<input model:value="{{ a.b }}" />
```

### 在自定义组件中触发双向绑定更新

自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData 设置自身的属性。例如：

```js
// custom-component.js
Component({
  properties: {
    myValue: String
  },
  methods: {
    update: function() {
      // 更新 myValue
      this.setData({
        myValue: 'leaf'
      })
    }
  }
})
```

如果页面这样使用这个组件：

```html
<custom-component model:my-value="{{pageValue}}" />
```

当组件使用 `setData` 更新 `myValue` 时，页面的 `this.data.pageValue` 也会同时变更，页面 WXML 中所有绑定了 `pageValue` 的位置也会被一同更新

## 获取界面上的节点信息

## WXML节点信息

[节点信息查询 API](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createSelectorQuery.html) 可以用于获取节点属性、样式、在界面上的位置等信息。

最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

**示例代码：**

```js
const query = wx.createSelectorQuery()
query.select('#the-id').boundingClientRect(function(res){
  res.top // #the-id 节点的上边界坐标（相对于显示区域）
})
query.selectViewport().scrollOffset(function(res){
  res.scrollTop // 显示区域的竖直滚动位置
})
query.exec()
```

上述示例中， `#the-id` 是一个节点选择器，与 CSS 的选择器相近但略有区别，请参见 [SelectorQuery.select](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.select.html) 的相关说明。

在自定义组件或包含自定义组件的页面中，推荐使用 `this.createSelectorQuery` 来代替 [wx.createSelectorQuery](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createSelectorQuery.html) ，这样可以确保在正确的范围内选择节点

## 响应显示区域变化

#### 显示区域尺寸

显示区域指小程序界面中可以自由布局展示的区域。在默认情况下，小程序显示区域的尺寸自页面初始化起就不会发生变化。但以下两种方式都可以改变这一默认行为

#### 在手机上启用屏幕旋转支持

使小程序中的页面支持屏幕旋转的方法是：在 `app.json` 的 `window` 段中设置 `"pageOrientation": "auto"` ，或在页面 json 文件中配置 `"pageOrientation": "auto"` 。

以下是在单个页面 json 文件中启用屏幕旋转的示例。

**代码示例：**

```json
{
  "pageOrientation": "auto"
}
```

如果页面添加了上述声明，则在屏幕旋转时，这个页面将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。

从小程序基础库版本 [2.5.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始， `pageOrientation` 还可以被设置为 `landscape` ，表示固定为横屏显示

#### 在 iPad 上启用屏幕旋转支持

使小程序支持 iPad 屏幕旋转的方法是：在 `app.json` 中添加 `"resizable": true` 。

**代码示例：**

```json
{
  "resizable": true
}
```

如果小程序添加了上述声明，则在屏幕旋转时，小程序将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。注意：在 iPad 上不能单独配置某个页面是否支持屏幕旋转

#### Media Query

有时，对于不同尺寸的显示区域，页面的布局会有所差异。此时可以使用 media query 来解决大多数问题。

**代码示例：**

```css
.my-class {
  width: 40px;
}

@media (min-width: 480px) {
  /* 仅在 480px 或更宽的屏幕上生效的样式规则 */
  .my-class {
    width: 200px;
  }
}
```

在 WXML 中，可以使用 [match-media](https://developers.weixin.qq.com/miniprogram/dev/component/match-media.html) 组件来根据 media query 匹配状态展示、隐藏节点。

此外，可以在页面或者自定义组件 JS 中使用 `this.createMediaQueryObserver()` 方法来创建一个 [`MediaQueryObserver`](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/MediaQueryObserver.html) 对象，用于监听指定的 media query 的匹配状态

#### 屏幕旋转事件

有时，仅仅使用 media query 无法控制一些精细的布局变化。此时可以使用 js 作为辅助。

在 js 中读取页面的显示区域尺寸，可以使用 [selectorQuery.selectViewport](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.selectViewport.html) 。

页面尺寸发生改变的事件，可以使用页面的 `onResize` 来监听。对于自定义组件，可以使用 resize 生命周期来监听。回调函数中将返回显示区域的尺寸信息。（从基础库版本 [2.4.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始支持。）

**代码示例：**

```js
Page({
  onResize(res) {
    res.size.windowWidth // 新的显示区域宽度
    res.size.windowHeight // 新的显示区域高度
  }
})
Component({
  pageLifetimes: {
    resize(res) {
      res.size.windowWidth // 新的显示区域宽度
      res.size.windowHeight // 新的显示区域高度
    }
  }
})
```

## 定时器

### number setInterval(function callback, number delay, any rest)

每隔 number delay 毫秒执行一次 function

```javascript
   setInterval(()=>{console.log("hello");},2000)
```

参数

| 参数              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| function callback | 回调函数                                                     |
| number delay      | 执行回调函数之间的时间间隔，单位 ms。                        |
| any rest          | param1, param2, ..., paramN 等附加参数，它们会作为参数传递给回调函数。 |
| number            | 返回值，定时器的编号。这个值可以传递给 [clearInterval](https://developers.weixin.qq.com/miniprogram/dev/reference/api/clearInterval.html) 来取消该定时 |

### clearInterval(number intervalID)

取消由 setInterval 设置的定时器。

```javascript
 in(){
   let number = setInterval(()=>{console.log("hello");},2000)
   this.setData({number:number})
 },
 cl(){
   clearInterval(this.data.number)
 }
```

参数

| 参数              | 作用                |
| ----------------- | ------------------- |
| number intervalID | 要取消的定时器的 ID |

### number setTimeout(function callback, number delay, any rest)

设定一个定时器。在定时到期以后执行一次注册的回调函数

使用方法与setInterval相同

### clearTimeout(number timeoutID)

取消由 setTimeout 设置的定时器

使用方法与clearInterval相同

# API

## 基础

### boolean wx.canIUse(string schema)

判断小程序的API，回调，参数，组件等是否在当前版本可用

```javascript
console.log(wx.canIUse('console.log'));
```

参数可以是API名，方法名，组件名等等

### wx.getSystemInfo(Object object)

获取系统信息。**由于历史原因，wx.getSystemInfo 是异步的调用格式，但是是同步返回，需要异步获取系统信息请使用 [wx.getSystemInfoAsync](https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSystemInfoAsync.html)。**

使用方法

```javascript
 sys(){
   wx.getSystemInfo({
     success: (result) => {
       console.log(result)
     },
   })
 }
})
```

参数：

| 属性     | 类型     | 必填 | 说明                                             |
| :------- | :------- | :--- | :----------------------------------------------- |
| success  | function | 否   | 接口调用成功的回调函数                           |
| fail     | function | 否   | 接口调用失败的回调函数                           |
| complete | function | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

## 路由

### wx.navigateTo(Object object)

保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 [wx.navigateBack](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html) 可以返回到原页面。小程序中页面栈最多十层

使用方法：

```javascript
Page({
 tz(){
   wx.navigateTo({
     //需要使用从根目录pages的路径，需要传递的参数使用 ? 拼接在url后面
     url: '/pages/logs/logs?name="yyb"&age="18"',
   })
 }
})
```

在目标页面的生命周期函数 onLoad 中获取参数：

```javascript
Page({
  btn(){
    wx.navigateBack({
    })
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    this.setData({name:options.name,age:options.age})
  },
})
```

参数：

| 属性     | 类型     | 必填 | 说明                                                         |
| :------- | :------- | :--- | :----------------------------------------------------------- |
| url      | string   | 是   | 需要跳转的应用内非 tabBar 的页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 `?` 分隔，参数键与参数值用 `=` 相连，不同参数用 `&` 分隔；如 'path?key=value&key2=value2' |
| events   | Object   | 否   | 页面间通信接口，用于监听被打开页面发送到当前页面的数据。基础库 2.7.3 开始支持。 |
| success  | function | 否   | 接口调用成功的回调函数                                       |
| fail     | function | 否   | 接口调用失败的回调函数                                       |
| complete | function | 否   | 接口调用结束的回调函数（调用成功、失败都会执行）             |

### wx.navigateBack(Object object)

关闭当前页面，返回上一页面或多级页面。可通过 [getCurrentPages](https://developers.weixin.qq.com/miniprogram/dev/reference/api/getCurrentPages.html) 获取当前的页面栈，决定需要返回几层。

使用：

```javascript
Page({
  btn(){
    wx.navigateBack({
    })
  }
})
```

参数:

| 属性     | 类型     | 默认值 | 必填 | 说明                                                    |
| :------- | :------- | :----- | :--- | :------------------------------------------------------ |
| delta    | number   | 1      | 否   | 返回的页面数，如果 delta 大于现有页面数，则返回到首页。 |
| success  | function |        | 否   | 接口调用成功的回调函数                                  |
| fail     | function |        | 否   | 接口调用失败的回调函数                                  |
| complete | function |        | 否   | 接口调用结束的回调函数（调用成功、失败都会执行）        |

### wx.redirectTo(Object object)

关闭当前页面，重定向到应用内的某个页面。但是不允许跳转到 tabbar 页面

使用方法与跳转`wx.navigateTo(Object object)`相同

### wx.reLaunch(Object object)

关闭所有页面，打开到应用内的某个页面

使用方法与跳转`wx.navigateTo(Object object)`相同

## 界面

### 交互

#### wx.showToast(Object object)

显示消息提示框

使用方法：

```javascript
xxts(){
   wx.showToast({
     title: '新消息',
     icon:'none',
     duration:3000
   })
 }
```

**参数：**

| 属性     | 类型     | 默认值  | 必填 | 说明                                             |
| :------- | :------- | :------ | :--- | :----------------------------------------------- |
| title    | string   |         | 是   | 提示的内容                                       |
| icon     | string   | success | 否   | 图标                                             |
| image    | string   |         | 否   | 自定义图标的本地路径，image 的优先级高于 icon    |
| duration | number   | 1500    | 否   | 提示的延迟时间                                   |
| mask     | boolean  | false   | 否   | 是否显示透明蒙层，防止触摸穿透                   |
| success  | function |         | 否   | 接口调用成功的回调函数                           |
| fail     | function |         | 否   | 接口调用失败的回调函数                           |
| complete | function |         | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

#### wx.showModal(Object object)

显示模态对话框

使用方法：

```javascript
 mt(){
   wx.showModal({
     cancelColor: 'cancelColor',
     title:'新消息',
     content:'是否删除aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
   })
 }
```

参数

| 属性            | 类型     | 默认值  | 必填 | 说明                                               |
| :-------------- | :------- | :------ | :--- | :------------------------------------------------- |
| title           | string   |         | 否   | 提示的标题                                         |
| content         | string   |         | 否   | 提示的内容                                         |
| showCancel      | boolean  | true    | 否   | 是否显示取消按钮                                   |
| cancelText      | string   | 取消    | 否   | 取消按钮的文字，最多 4 个字符                      |
| cancelColor     | string   | #000000 | 否   | 取消按钮的文字颜色，必须是 16 进制格式的颜色字符串 |
| confirmText     | string   | 确定    | 否   | 确认按钮的文字，最多 4 个字符                      |
| confirmColor    | string   | #576B95 | 否   | 确认按钮的文字颜色，必须是 16 进制格式的颜色字符串 |
| editable        | boolean  | false   | 否   | 是否显示输入框                                     |
| placeholderText | string   |         | 否   | 显示输入框时的提示文本                             |
| success         | function |         | 否   | 接口调用成功的回调函数                             |
| fail            | function |         | 否   | 接口调用失败的回调函数                             |
| complete        | function |         | 否   | 接口调用结束的回调函数（调用成功、失败都会执行）   |

#### wx.showLoading(Object object)

显示 loading 提示框。需主动调用 wx.hideLoading 才能关闭提示框

使用方法：

```javascript
 loading(){
   wx.showLoading({
     title: '加载中',
   })
 }
```

参数

| 属性     | 类型     | 默认值 | 必填 | 说明                                             |
| :------- | :------- | :----- | :--- | :----------------------------------------------- |
| title    | string   |        | 是   | 提示的内容                                       |
| mask     | boolean  | false  | 否   | 是否显示透明蒙层，防止触摸穿透                   |
| success  | function |        | 否   | 接口调用成功的回调函数                           |
| fail     | function |        | 否   | 接口调用失败的回调函数                           |
| complete | function |        | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

#### wx.hideLoading(Object object)

隐藏 loading 提示框

使用方法：

```javascript
yc(){
   wx.hideLoading({
   })
 }
```

参数

| 属性     | 类型     | 必填 | 说明                                             |
| :------- | :------- | :--- | :----------------------------------------------- |
| success  | function | 否   | 接口调用成功的回调函数                           |
| fail     | function | 否   | 接口调用失败的回调函数                           |
| complete | function | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

#### wx.showActionSheet(Object object)

显示操作菜单

```javascript
 cz(){
   wx.showActionSheet({
     itemList: ['aaaaa','bbbbb','ccccc','ddddd'],
     success(res){
       console.log(res.tapIndex+"点击成功");
     },
     fail(res){
       console.log(res);
     }
   })
 }
```

参数：

| 属性      | 类型           | 默认值  | 必填 | 说明                                             |
| :-------- | :------------- | :------ | :--- | :----------------------------------------------- |
| alertText | string         |         | 否   | 警示文案                                         |
| itemList  | Array.<string> |         | 是   | 按钮的文字数组，数组长度最大为 6                 |
| itemColor | string         | #000000 | 否   | 按钮的文字颜色                                   |
| success   | function       |         | 否   | 接口调用成功的回调函数                           |
| fail      | function       |         | 否   | 接口调用失败的回调函数                           |
| complete  | function       |         | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

## 网络

### wx.request(Object object)

发起 HTTPS 网络请求。使用前请注意阅读[相关说明](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)

参数

| 属性     | 类型                      | 默认值 | 必填 | 说明                                                         |
| :------- | :------------------------ | :----- | :--- | :----------------------------------------------------------- |
| url      | string                    |        | 是   | 开发者服务器接口地址                                         |
| data     | string/object/ArrayBuffer |        | 否   | 请求的参数                                                   |
| header   | Object                    |        | 否   | 设置请求的 header，header 中不能设置 Referer。 `content-type` 默认为 `application/json` |
| timeout  | number                    |        | 否   | 超时时间，单位为毫秒                                         |
| method   | string                    | GET    | 否   | HTTP 请求方法                                                |
| dataType | string                    | json   | 否   | 返回的数据格式                                               |

注意：

- 域名只支持 `https` ([wx.request](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html)、[wx.uploadFile](https://developers.weixin.qq.com/miniprogram/dev/api/network/upload/wx.uploadFile.html)、[wx.downloadFile](https://developers.weixin.qq.com/miniprogram/dev/api/network/download/wx.downloadFile.html)) 和 `wss` ([wx.connectSocket](https://developers.weixin.qq.com/miniprogram/dev/api/network/websocket/wx.connectSocket.html)) 协议；
- 域名不能使用 IP 地址（小程序的[局域网](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/mDNS.html) IP 除外）或 localhost；
- 可以配置端口，如 https://myserver.com:8080，但是配置后只能向 https://myserver.com:8080 发起请求。如果向 https://myserver.com、https://myserver.com:9091 等 URL 请求则会失败。
- 如果不配置端口。如 https://myserver.com，那么请求的 URL 中也不能包含端口，甚至是默认的 443 端口也不可以。如果向 https://myserver.com:443 请求则会失败。
- 域名必须经过 ICP 备案；
- **出于安全考虑，`api.weixin.qq.com` 不能被配置为服务器域名，相关API也不能在小程序内调用。** 开发者应将 AppSecret 保存到后台服务器中，通过服务器使用 `getAccessToken` 接口获取 `access_token`，并调用相关 API；
- 不支持配置父域名，使用子域名
